{"version":3,"file":"two-fa/assets.min.js","mappings":"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;IACJ;EAAC;AAAA,EAlBkBpO,iDAAQ;AAqB/B,iEAAe+gB,QAAQ;;;;;;;;;;;ACxBX;;AAEZ,kBAAkB;AAClB,mBAAmB;AACnB,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,iEAAc;AACzC;AACA,+BAA+B;AAC/B,QAAQ,MAAM;AACd;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA,+BAA+B;AAC/B,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;;ACpCF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;ACnBf,qHAAoD;AACpD,yBAAsB;;;;;;;;;;;;ACDtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,eAAe,mBAAO,CAAC,oDAAW;AAClC,gBAAgB,mBAAO,CAAC,gDAAS;AACjC;AACA;AACA;AACA;;AAEA,cAAc;AACd,kBAAkB;AAClB,yBAAyB;;AAEzB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,yBAAyB,QAAQ;AACjC;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,qBAAqB,WAAW,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,gBAAgB,WAAW,GAAG,IAAI,KAAK,aAAa;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;;AAEA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,KAAK,mDAAmD,cAAc;AACzF,GAAG;AACH;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;AACtD;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,SAAS,gBAAgB;AACzB,cAAc,oBAAoB,EAAE,IAAI;AACxC;AACA,YAAY,gBAAgB,EAAE,IAAI;AAClC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG,SAAS,GAAG,KAAK,qBAAqB,EAAE,EAAE;AACpE,QAAQ;AACR,yBAAyB,GAAG,KAAK,yBAAyB,EAAE,EAAE;AAC9D,mBAAmB,yBAAyB,EAAE,EAAE;AAChD;AACA,MAAM;AACN,oBAAoB,IAAI,EAAE,GAAG,SAAS,IAAI,EAAE,EAAE;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,cAAc,SAAS,OAAO;AACxE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACzjEY;;AAEZ,kBAAkB,mBAAO,CAAC,yDAAa;AACvC,iBAAiB,mBAAO,CAAC,uDAAY;AACrC,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,eAAe,mBAAO,CAAC,mDAAU;AACjC,eAAe,mBAAO,CAAC,mDAAU;AACjC,YAAY,mBAAO,CAAC,6CAAO;AAC3B,2BAA2B,mBAAO,CAAC,2EAAsB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA,2BAA2B,gCAAgC;AAC3D;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,yBAAyB;AACpD;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA,2BAA2B,4BAA4B;AACvD;AACA;;AAEA;AACA,2BAA2B,8BAA8B;AACzD;AACA;;AAEA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;;AAEA;AACA;AACA,MAAM,2DAA2D;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,qBAAqB,KAAK;AAC1B,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACjHY;;AAEZ,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,cAAc,mBAAO,CAAC,iDAAS;AAC/B,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,OAAO,oBAAoB,EAAE,mBAAO,CAAC,yDAAa;AAClD,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA,WAAW,8CAA8C;AACzD;AACA,WAAW,iBAAiB;AAC5B,cAAc,+CAA+C;AAC7D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,iBAAiB;AAC3D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,UAAU,gBAAgB;AACxC;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB,WAAW;AACxC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,6BAA6B,wCAAwC;;AAErE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,kCAAkC;AAClC,aAAa,8CAA8C,WAAW;AACtE;AACA,aAAa,iBAAiB;AAC9B,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,MAAM,aAAa;AACnB;AACA,WAAW,2BAA2B;AACtC;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,iBAAiB,MAAM,OAAO,KAAK,MAAM,YAAY;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA,iBAAiB,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA,sBAAsB,MAAM,qBAAqB;AACjD,UAAU;AACV,sBAAsB,MAAM,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,8BAA8B,KAAK,MAAM,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,4BAA4B,KAAK,MAAM,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,wBAAwB,MAAM,qBAAqB;AACnD,YAAY;AACZ,wBAAwB,MAAM,qBAAqB;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC9XY;;AAEZ;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;;AAEf,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EY;;AAEZ,0BAA0B,mBAAO,CAAC,8FAA+B;AACjE,eAAe,mBAAO,CAAC,mDAAU;AACjC,eAAe,mBAAO,CAAC,mDAAU;AACjC,cAAc,mBAAO,CAAC,iDAAS;AAC/B,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,kBAAkB,mBAAO,CAAC,yDAAa;AACvC,OAAO,wBAAwB;AAC/B,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;;AAEjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;AACA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,QAAQ;AACtB,2CAA2C,+BAA+B;AAC1E,MAAM,mCAAmC;AACzC;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,iCAAiC;AACjC;AACA,cAAc,eAAe;AAC7B;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB,kDAAkD,sBAAsB;AACxE;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa;AACb;AACA;AACA,WAAW,sCAAsC;AACjD;AACA,WAAW,gBAAgB;AAC3B,cAAc,8CAA8C;AAC5D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,gBAAgB;AAC1D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB,WAAW;AACxC;AACA,0BAA0B;AAC1B;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,WAAW,wCAAwC;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,KAAK;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA,aAAa,uBAAuB,WAAW;AAC/C,eAAe,qBAAqB;AACpC,cAAc,qBAAqB;AACnC,cAAc,OAAO;AACrB;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,MAAM,SAAS;AACf,WAAW,2BAA2B;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,aAAa,YAAY;AACzB,aAAa,uBAAuB,WAAW;AAC/C;AACA,eAAe,mCAAmC;AAClD,cAAc,WAAW;AACzB,cAAc,OAAO;AACrB;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,MAAM,SAAS;AACf,WAAW,2BAA2B;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,mBAAmB;AACzB;AACA;AACA,aAAa,YAAY;AACzB,aAAa,sCAAsC,WAAW;AAC9D;AACA,aAAa,gBAAgB;AAC7B,eAAe,8BAA8B;AAC7C;AACA,cAAc,WAAW;AACzB;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,6CAA6C;;AAExD;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,mCAAmC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,yCAAyC,WAAW;AACjE;AACA,aAAa,mBAAmB;AAChC,eAAe,4CAA4C;AAC3D;AACA,cAAc,WAAW;AACzB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,2BAA2B;;AAEtC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,gCAAgC;AAC/C;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,gBAAgB;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,GAAG;AACjE;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1qBY;;AAEZ,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,cAAc,mBAAO,CAAC,iDAAS;AAC/B,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,OAAO,UAAU,EAAE,mBAAO,CAAC,yDAAa;;AAExC;AACA;AACA;AACA,aAAa;AACb,gCAAgC;AAChC;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA;AACA,iCAAiC;AACjC;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,WAAW,yCAAyC;AACpD;AACA,WAAW,kBAAkB;AAC7B,cAAc,iDAAiD;AAC/D,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,iBAAiB,kBAAkB;AAC5D;AACA,cAAc,UAAU,qBAAqB,gBAAgB,UAAU;AACvE;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB,WAAW;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,YAAY;AACzB,aAAa,0CAA0C,WAAW;AAClE;AACA,aAAa,kBAAkB;AAC/B,eAAe,SAAS;AACxB,cAAc,WAAW;AACzB;AACA,qCAAqC;AACrC;AACA;AACA;AACA,MAAM,aAAa;AACnB,WAAW,2BAA2B;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACjRY;;AAEZ,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,cAAc,mBAAO,CAAC,iDAAS;AAC/B,kBAAkB,mBAAO,CAAC,yDAAa;AACvC;AACA;AACA,EAAE;AACF,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa,iCAAiC;AAC9C,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA,cAAc,mCAAmC;AACjD;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB,WAAW;AACzC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA,6CAA6C,SAAS;AACtD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,WAAW;AACxB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,MAAM;AACnB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,eAAe;AAC5B,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,gBAAgB;AAC7B,eAAe,iBAAiB;AAChC;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,eAAe;AAClE;AACA;AACA;AACA,2BAA2B,WAAW,IAAI,2DAA2D;AACrG;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,MAAM;AACnB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,mBAAmB;AAChC,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;;AAEjB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,cAAc,cAAc;AAC5B,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,gCAAgC;AAC7C;AACA,aAAa,iBAAiB,WAAW;AACzC,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,iBAAiB,WAAW;AACzC,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,iBAAiB,WAAW;AACzC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACnmCY;;AAEZ,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;AACjC,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,OAAO,IAAI,EAAE,mBAAO,CAAC,yDAAa;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,aAAa,KAAK;AAClB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,eAAe,SAAS;AACxB,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,oCAAoC;AACjD;AACA,aAAa,KAAK;AAClB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACnLY;;AAEZ;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACtEY;;AAEZ,gBAAgB,mBAAO,CAAC,qDAAW;AACnC,uBAAuB,mBAAO,CAAC,mEAAkB;AACjD,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;;AAEjC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,mCAAmC;AAChD;AACA,eAAe,SAAS;AACxB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,qCAAqC,WAAW;AAC7D;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,qCAAqC,WAAW;AAC7D;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;;AC7IY;;AAEZ,OAAO,kBAAkB,EAAE,mBAAO,CAAC,yDAAa;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA,iEAAiE,MAAM;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA,qBAAqB,WAAW;AAChC;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA,eAAe,wCAAwC;AACvD,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACvGY;;AAEZ,kBAAkB,mBAAO,CAAC,yDAAa;AACvC,cAAc,mBAAO,CAAC,iDAAS;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ,mCAAmC;AACtD;AACA,aAAa,KAAK;AAClB;;AAEA;AACA;AACA;AACA;AACA,aAAa,8BAA8B;AAC3C;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA,gCAAgC;AAChC;AACA,4BAA4B;AAC5B;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,gDAAgD;AAChD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,6CAA6C;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,6CAA6C;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH,UAAU;AACV;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,cAAc,SAAS,GAAG,2BAA2B;AACrD;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3XY;;AAEZ,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;AACjC,iBAAiB,mBAAO,CAAC,sDAAU;AACnC,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,kBAAkB,mBAAO,CAAC,yDAAa;AACvC,OAAO,6BAA6B;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6BAA6B;AACjE,YAAY;AACZ,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,GAAG;AAC7D;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,6CAA6C;AAC7C;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,SAAS,oCAAoC;AAC7C;;AAEA;;AAEA,WAAW;AACX,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;;AAEA,WAAW;AACX;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,qBAAqB,oBAAoB;AACzC;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE,GAAG,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0DAA0D;AACrE;AACA,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,WAAW,0DAA0D;AACrE;AACA,aAAa,QAAQ;AACrB;AACA;AACA,cAAc;AACd;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;;;;;;;;;;;;ACnTA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEY;AACZ,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,iBAAiB,mBAAO,CAAC,sDAAU;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,gBAAgB;AAC7B,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,YAAY;AAC1E;AACA,8DAA8D,YAAY;AAC1E;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;;;;;;;;;;AChfA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA;AACA,SAAS,WAAW;;AAEpB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,SAAS,WAAW;;AAEpB;AACA;AACA,SAAS,UAAU;;AAEnB;AACA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1BY;;AAEZ,eAAe,mBAAO,CAAC,yDAAQ;AAC/B,OAAO,QAAQ,EAAE,mBAAO,CAAC,8CAAQ;AACjC,oCAAoC,6BAA6B;;AAEjE;AACA,aAAa,QAAQ;AACrB,cAAc,eAAe;AAC7B,cAAc,gBAAgB;AAC9B;AACA,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,SAAS;AACvB;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,QAAQ;AACtB;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8CAA8C;AAC3D,aAAa,gCAAgC;AAC7C;AACA,aAAa,iBAAiB;AAC9B;AACA,gDAAgD;AAChD;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB,eAAe,QAAQ;AACvB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,gCAAgC,WAAW,WAAW,KAAK;AAC3D;AACA,MAAM;AACN,mDAAmD,KAAK;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,MAAM;AACzD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,QAAQ;AACvB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,eAAe,SAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,uBAAuB,GAAG,IAAI;AAC5C;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9hCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;ACvL7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,QAAQ;;AAE/B;;AAEA,yBAAyB,QAAQ;;AAEjC;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,sBAAsB,OAAO;;AAE7B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAsB,gBAAgB;;AAEtC,wBAAwB,gBAAgB;;AAExC;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,QAAQ;;AAEnC,6BAA6B,QAAQ;;AAErC;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sBAAsB,QAAQ;;AAE9B;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;;AAE9B;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;;AAEhD;;AAEA;;AAEA,0BAA0B,OAAO;;AAEjC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,qBAAqB;;AAE3C;AACA;;AAEA;AACA;;AAEA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;;AAEA;AACA;;AAEA,sBAAsB,gBAAgB;AACtC,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,gBAAgB;AACtC,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,iBAAiB;AAChC;AACA;;AAEA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,mBAAmB;AACxD,4CAA4C;AAC5C,gCAAgC,yBAAyB;AACzD;AACA;;AAEA,sBAAsB,4BAA4B;;AAElD;;AAEA,wBAAwB,4BAA4B;AACpD;AACA,yCAAyC,mBAAmB;AAC5D,gDAAgD;AAChD,oCAAoC,YAAY;AAChD,gDAAgD;AAChD,iDAAiD;AACjD;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,WAAW;AACpD;AACA;;AAEA;AACA,6CAA6C,aAAa;AAC1D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA,kCAAkC,GAAG;AACrC,kCAAkC,GAAG;AACrC,mCAAmC,GAAG;AACtC,oCAAoC,GAAG;AACvC,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA,oBAAoB,UAAU;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA,oBAAoB,UAAU;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;;AAER;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;;AAER;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C,0BAA0B,mBAAmB;;AAE7C;AACA;;AAEA,2BAA2B,QAAQ;;AAEnC;AACA;AACA;;AAEA,6BAA6B,QAAQ;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,uBAAuB;AAC/C,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,mBAAmB;AAC3C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAsB,uBAAuB;AAC7C,wBAAwB,mBAAmB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sBAAsB,YAAY;;AAElC;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,UAAU;;AAEV;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,YAAY;AAChC,sBAAsB,WAAW;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA,MAAM,IAA0C;AAChD,MAAM,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,kGAAC;AACzB,IAAI,KAAK,EAEN;AACH,CAAC;AACD;AACA,CAAC;;;;;;;;;;;;ACxvEY;;AAEb,gDAAgD,0DAA0D,2CAA2C;;AAErJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;;;AAGF;AACA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA,EAAE;;;AAGF;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,oBAAoB;;;;;;;;;;;;;AC9HpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,kFAAoB;AAC3C,eAAe,mBAAO,CAAC,kFAAoB;AAC3C,mBAAO,CAAC,6DAAU;AAClB;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;AC7HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;AACA,gBAAgB,mBAAO,CAAC,oFAAqB;AAC7C,mBAAO,CAAC,6DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,mFAA8B;AACvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,wGAA2B;AAChD;;AAEA,aAAa,4EAAwB;AACrC,4BAA4B,qBAAM,mBAAmB,qBAAM,mFAAmF;AAC9I;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAO,CAAC,mBAAM;AAC9B;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,0GAAgC;AACzD,kBAAkB,mBAAO,CAAC,kGAA4B;AACtD,eAAe,mBAAO,CAAC,8FAA0B;AACjD;AACA,qBAAqB,gGAA0B;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAO,CAAC,6DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,mFAAmF;AAC5J;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iHAAwC;AAChF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,+FAA+F;AAC/F,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA,4FAA4F;AAC5F,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,iHAAwC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO,oBAAoB,OAAO;AAClG;AACA,wBAAwB,OAAO,iBAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAO,CAAC,gHAAmC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mDAAmD,+DAA+D;AAClH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,oGAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;;;;;;;;;;AClgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA,qBAAqB,gGAA0B;AAC/C;AACA;AACA;AACA;AACA,aAAa,mBAAO,CAAC,8EAAkB;AACvC,mBAAO,CAAC,6DAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,gEAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,wGAA2B;AAChD;;AAEA,aAAa,4EAAwB;AACrC,4BAA4B,qBAAM,mBAAmB,qBAAM,mFAAmF;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,CAAC,kGAA4B;AACtD,eAAe,mBAAO,CAAC,8FAA0B;AACjD;AACA,qBAAqB,gGAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAO,CAAC,6DAAU;AAClB;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sDAAsD;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI,OAAO;AACX;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChoBa;;AAEb;AACA,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,+BAA+B,uCAAuC;AACtE,qCAAqC,+DAA+D,sCAAsC,0BAA0B,+CAA+C,yCAAyC,uEAAuE;AACnU,eAAe,mBAAO,CAAC,6FAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;AACA,yFAAyF;AACzF;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;ACnLa;;AAEb,2CAA2C,gCAAgC,oCAAoC,oDAAoD,6DAA6D,iEAAiE,sCAAsC;AACvU,iCAAiC,gBAAgB,sBAAsB,OAAO,uDAAuD,6DAA6D,4CAA4C,oKAAoK,mFAAmF,KAAK;AAC1e,4CAA4C,2BAA2B,kBAAkB,kCAAkC,oEAAoE,KAAK,OAAO,oBAAoB;AAC/N,kDAAkD,0CAA0C;AAC5F,4CAA4C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD;AAC/P,8DAA8D,sEAAsE,8DAA8D,kDAAkD,iBAAiB,GAAG;AACxQ,+BAA+B,uCAAuC;AACtE,qCAAqC,+DAA+D,sCAAsC,0BAA0B,+CAA+C,yCAAyC,uEAAuE;AACnU,eAAe,mBAAO,CAAC,8CAAQ;AAC/B;AACA,gBAAgB,mBAAO,CAAC,mBAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;ACtLY;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,OAAO;AACf,QAAQ;AACR;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf,QAAQ;AACR;AACA,QAAQ,OAAO;AACf,QAAQ;AACR,QAAQ,OAAO;AACf;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA,MAAM;AACN,MAAM,OAAO;AACb;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/FA;AACA;;AAEa;;AAEb,iCAAiC,sGAAgC;AACjE;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrFA;AACA;AACA;;;;;;;;;;;;ACFA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sGAAgC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,+BAA+B,mBAAO,CAAC,6FAAiB;AACxD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,aAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACrFa;;AAEb,4BAA4B,sGAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACrBA,kGAA+C;;;;;;;;;;;ACA/C;AACA;AACA,aAAa,mBAAO,CAAC,8CAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,mFAA8B;AACvC,eAAe,mBAAO,CAAC,6DAAU;;AAEjC;AACA,kBAAkB,mBAAO,CAAC,uGAAyC;AACnE,kBAAkB,mBAAO,CAAC,uGAAyC;AACnE,gBAAgB,mBAAO,CAAC,mGAAuC;AAC/D,mBAAmB,mBAAO,CAAC,yGAA0C;AACrE,qBAAqB,mBAAO,CAAC,6GAA4C;AACzE,kBAAkB,mBAAO,CAAC,mIAAuD;AACjF,kBAAkB,mBAAO,CAAC,yHAAkD;;AAE5E;AACA;;;;AAIA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,sFAA6B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA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","sources":["webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/BaseAuth.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/onboarding.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/passkey-login.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/passkey-table-manager.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/passkey.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/profile.js","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/validate.js","webpack://really-simple-ssl/./node_modules/base64-js/index.js","webpack://really-simple-ssl/./node_modules/base64url/dist/base64url.js","webpack://really-simple-ssl/./node_modules/base64url/dist/pad-string.js","webpack://really-simple-ssl/./node_modules/base64url/index.js","webpack://really-simple-ssl/./node_modules/buffer/index.js","webpack://really-simple-ssl/./node_modules/cbor/lib/cbor.js","webpack://really-simple-ssl/./node_modules/cbor/lib/commented.js","webpack://really-simple-ssl/./node_modules/cbor/lib/constants.js","webpack://really-simple-ssl/./node_modules/cbor/lib/decoder.js","webpack://really-simple-ssl/./node_modules/cbor/lib/diagnose.js","webpack://really-simple-ssl/./node_modules/cbor/lib/encoder.js","webpack://really-simple-ssl/./node_modules/cbor/lib/map.js","webpack://really-simple-ssl/./node_modules/cbor/lib/objectRecorder.js","webpack://really-simple-ssl/./node_modules/cbor/lib/sharedValueEncoder.js","webpack://really-simple-ssl/./node_modules/cbor/lib/simple.js","webpack://really-simple-ssl/./node_modules/cbor/lib/tagged.js","webpack://really-simple-ssl/./node_modules/cbor/lib/utils.js","webpack://really-simple-ssl/./node_modules/cbor/vendor/binary-parse-stream/index.js","webpack://really-simple-ssl/./node_modules/events/events.js","webpack://really-simple-ssl/./node_modules/ieee754/index.js","webpack://really-simple-ssl/./node_modules/inherits/inherits_browser.js","webpack://really-simple-ssl/./node_modules/nofilter/lib/index.js","webpack://really-simple-ssl/./node_modules/process/browser.js","webpack://really-simple-ssl/./node_modules/qrcode-generator/qrcode.js","webpack://really-simple-ssl/./node_modules/readable-stream/errors-browser.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/_stream_duplex.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/_stream_passthrough.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/_stream_readable.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/_stream_transform.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/_stream_writable.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/async_iterator.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/buffer_list.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/end-of-stream.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/from-browser.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/pipeline.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/state.js","webpack://really-simple-ssl/./node_modules/readable-stream/lib/internal/streams/stream-browser.js","webpack://really-simple-ssl/./node_modules/safe-buffer/index.js","webpack://really-simple-ssl/./node_modules/stream-browserify/index.js","webpack://really-simple-ssl/./node_modules/string_decoder/lib/string_decoder.js","webpack://really-simple-ssl/./node_modules/util-deprecate/browser.js","webpack://really-simple-ssl/ignored|/Users/marcelsanting/PhpstormProjects/really-simple-ssl-pro/settings/node_modules/readable-stream/lib/internal/streams|util","webpack://really-simple-ssl/ignored|/Users/marcelsanting/PhpstormProjects/really-simple-ssl-pro/settings/node_modules/readable-stream/lib|util","webpack://really-simple-ssl/./node_modules/@passwordless-id/webauthn/dist/browser/webauthn.min.js","webpack://really-simple-ssl/webpack/bootstrap","webpack://really-simple-ssl/webpack/runtime/compat get default export","webpack://really-simple-ssl/webpack/runtime/define property getters","webpack://really-simple-ssl/webpack/runtime/global","webpack://really-simple-ssl/webpack/runtime/hasOwnProperty shorthand","webpack://really-simple-ssl/webpack/runtime/make namespace object","webpack://really-simple-ssl/../security/wordpress/two-fa/assets/js/index.js"],"sourcesContent":["import qrcode from 'qrcode-generator'\nclass BaseAuth {\n    constructor(root, settings) {\n        this.root = root;\n        this.settings = settings;\n        this.translatableStrings = {\n            keyCopied: this.settings.translatables.keyCopied,\n            webauthn_not_available: this.settings.translatables.webauthn_not_available,\n            unknown_error: this.settings.translatables.unknown_error,\n            response_error: this.settings.translatables.response_error,\n            passkey_not_found: this.settings.translatables.passkey_not_found,\n            passkey_login_error: this.settings.translatables.passkey_login_error,\n            passkey_registration_error: this.settings.translatables.passkey_registration_error,\n            passkey_login_success: this.settings.translatables.passkey_login_success,\n            passkey_configuration: this.settings.translatables.passkey_configuration,\n            error_assertion: this.settings.translatables.error_assertion,\n            notice_inform: this.settings.translatables.notice_inform,\n            register_passkey: this.settings.translatables.register_passkey,\n            network_not_ok: this.settings.translatables.network_not_ok,\n            error_complete_registration: this.settings.translatables.error_complete_registration,\n            usb: this.settings.translatables.usb,\n            nfc: this.settings.translatables.nfc,\n            ble: this.settings.translatables.ble,\n            internal: this.settings.translatables.internal,\n            cross_platform: this.settings.translatables.cross_platform,\n            unknown: this.settings.translatables.unknown,\n            pending: this.settings.translatables.pending,\n            success: this.settings.translatables.success,\n            login: this.settings.translatables.login,\n            login_failed: this.settings.translatables.login_failed,\n            log_in_with_passkey: this.settings.translatables.log_in_with_passkey,\n            or: this.settings.translatables.or,\n        };\n    }\n    getElement = (id) => document.getElementById(id);\n\n    getCheckedInputValue = (name) => document.querySelector(`input[name=\"${name}\"]:checked`).value;\n\n    /**\n     * Performs a fetch operation.\n     *\n     * @param {string} urlExtension - The URL extension to perform the fetch operation on.\n     * @param {Object} data - The data to be sent in the fetch operation.\n     * @param {string} [method='POST'] - The HTTP method to be used in the fetch operation. Defaults to 'POST'.\n     * @returns {Promise} - A Promise that resolves with the response of the fetch operation.\n     */\n    performFetchOp = (urlExtension, data, method = 'POST') => {\n        let url = this.root + urlExtension;\n        let fetchParams = {\n            method: method,\n            headers: {'Content-Type': 'application/json',},\n        };\n        if (method === 'POST') {\n            fetchParams.body = JSON.stringify(data);\n        }\n        return fetch(url, fetchParams);\n    };\n\n    assignClickListener = (id, callback) => {\n        const element = this.getElement(id);\n        if (element) {\n            element.addEventListener('click', function (e) {\n                e.preventDefault();\n                callback();\n            });\n        }\n    }\n\n\n\n    logFetchError = (error) => console.error('There has been a problem with your fetch operation:', error);\n\n    /**\n     * Generates a QR code for Two-Factor Authentication using the TOTP URL.\n     * If the TOTP URL is not available, nothing will be generated.\n     *\n     * @function qr_generator\n     * @returns {void} Nothing is returned.\n     */\n    qr_generator = () => {\n        const totp_url = this.settings.totp_data.totp_url;\n        if (!totp_url) {\n            return;\n        }\n\n        let qr = qrcode(0, 'L');\n        qr.addData(totp_url);\n        qr.make();\n        let qrElem = document.querySelector('#two-factor-qr-code a');\n        if (qrElem != null) {\n            let svgString = qr.createSvgTag(5);\n            // Replace xMinYMin with xMidYMid for proper centering\n            svgString = svgString.replace('preserveAspectRatio=\"xMinYMin meet\"', 'preserveAspectRatio=\"xMidYMid meet\"');\n            qrElem.innerHTML = svgString;\n        }\n    };\n\n    /**\n     * Downloads backup codes as a text file.\n     *\n     * @function download_codes\n     */\n    download_codes = () => {\n        let TextToCode = this.settings.totp_data.backup_codes;\n        let TextToCodeString = '';\n        TextToCode.forEach(function (item) {\n            TextToCodeString += item + '\\n';\n        });\n        let downloadLink = document.createElement('a');\n        downloadLink.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(TextToCodeString));\n        downloadLink.setAttribute('download', 'backup_codes.txt');\n        downloadLink.style.display = 'none';\n        document.body.appendChild(downloadLink);\n        downloadLink.click();\n        document.body.removeChild(downloadLink);\n    };\n\n    /**\n     * This function copies the text from the `totp_data.key` property of the `settings` object\n     * using the Clipboard API. It then shows a success message and reverts back to the original display\n     * after a specified timeout.\n     *\n     * @function copyTextAndShowMessage\n     * @memberof BaseAuth\n     */\n    copyTextAndShowMessage = () => {\n        let text = this.settings.totp_data.key; // Get the text to be copied\n        if(this.getElement('totp-key') === null) {\n            return;\n        }\n\n        // Use Clipboard API to copy the text\n        navigator.clipboard.writeText(text).then(() => {\n            // Change the display of the key\n            let originalText = this.getElement('totp-key').innerText;\n            this.getElement('totp-key').innerText = this.settings.translatables.keyCopied;\n            this.getElement('totp-key').style.color = 'green';\n\n            // Revert back to original text after a timeout\n            setTimeout(() => {\n                this.getElement('totp-key').innerText = originalText;\n                this.getElement('totp-key').style.color = ''; // Reset the color\n            }, 2000); // Adjust timeout as needed\n\n        }, function (err) {\n            console.error(this.settings.translatables.keyCopiedFailed, err);\n        });\n    }\n\n}\n\nexport default BaseAuth;","import BaseAuth from './BaseAuth';\nimport Passkey from \"./passkey\"; // New import for Passkey class\nclass Onboarding extends BaseAuth {\n\n    init() {\n        const translatableStrings = {\n            keyCopied: 'Key copied',\n        };\n\n        let endpoints = ['do_not_ask_again', 'skip_onboarding'];\n        this.passkey = new Passkey(this.root, this.settings); // New instance of Passkey added\n        this.passkey.init(); // Initializing Passkey\n        let that = this;\n\n        endpoints.forEach(endpoint => {\n            let endpointsElement = this.getElement(endpoint);\n            if (endpointsElement !== null) {\n                endpointsElement.addEventListener('click', (event) => { // Use arrow function here\n                    event.preventDefault();\n                    // we call the performFetchOp method and then log the response\n                    this.performFetchOp(`/${endpoint}`, this.settings)\n                        .then(response => response.json())\n                        // We log the data and redirect to the redirect_to URL\n                        .then(data => window\n                            .location\n                            .href = data.redirect_to)\n                        // We catch any errors and log them\n                        .catch(this.logFetchError);\n                });\n            }\n        });\n\n        let endpointElem = this.getElement('rsssl_continue_onboarding');\n        const handleClick = (event) => {\n            event.preventDefault();\n            let urlExtension = '';\n            let selectedProvider = this.getCheckedInputValue('preferred_method');\n            if (selectedProvider === 'email') {\n                let data = {\n                    provider: selectedProvider,\n                    redirect_to: this.settings.redirect_to,\n                    user_id: this.settings.user_id,\n                    login_nonce: this.settings.login_nonce\n                };\n                urlExtension = '/save_default_method_email';\n                this.performFetchOp(urlExtension, data)\n                    .then(response => response.json())\n                    .then(data => {\n                        this.getElement('rsssl_step_one_onboarding').style.display = 'none';\n                        const validation_check = document.getElementById(\"rsssl_step_four_onboarding\");\n                        validation_check.style.display = \"block\";\n                        // Removing the 'click' event listener from the rsssl_continue_onboarding id button\n                        endpointElem.addEventListener('click', (event) => handleValidation(event, data));\n                        endpointElem.removeEventListener('click', handleClick);\n\n                    })\n                    .catch(that.logFetchError);\n            } else if (selectedProvider === 'totp') {\n                // Hiding step one and showing step two\n                this.getElement('rsssl_step_one_onboarding').style.display = 'none';\n                // We hide this element\n                endpointElem.style.display = 'none';\n                this.getElement('rsssl_step_two_onboarding').style.display = 'block';\n            } else if (selectedProvider === 'passkey') { // New Passkey handling block\n                this.getElement('rsssl_step_one_onboarding').style.display = 'none';\n                endpointElem.style.display = 'none';\n                this.getElement('rsssl_step_three_onboarding').style.display = 'block';\n                // Trigger Passkey registration from Onboarding\n                this.passkey.fireRegistration().then(r => {\n                    if (r) {\n                        this.getElement('rsssl_step_three_onboarding').style.display = 'none';\n                        this.getElement('rsssl_step_four_onboarding').style.display = 'block';\n                    }\n                });\n            }\n        }\n\n        const handleValidation = async (event, data) => {\n            event.preventDefault();\n            let selectedProvider = this.getCheckedInputValue('preferred_method');\n            let urlExtension = '/' + data.validation_action;\n            let sendData = {\n                user_id: this.settings.user_id,\n                login_nonce: this.settings.login_nonce,\n                redirect_to: this.settings.redirect_to,\n                token: document.getElementById('rsssl-authcode').value,\n                provider: selectedProvider\n            };\n            let response;\n            try {\n                response = await this.performFetchOp(urlExtension, sendData);\n            } catch (err) {\n                console.log('Fetch Error: ', err);\n            }\n            if (response && !response.ok) {\n                let error = await response.json();\n                this.displayTwoFaOnboardingError(error.error);\n            }\n            if (response && response.ok) {\n                let data = await response.json();\n                window.location.href = data.redirect_to;\n            }\n        };\n\n        if (endpointElem !== null) {\n            endpointElem.addEventListener('click', handleClick);\n        }\n\n        let totpSubmit = this.getElement('two-factor-totp-submit');\n        if (totpSubmit !== null) {\n            totpSubmit.addEventListener('click', async (event) => {\n                event.preventDefault();\n                let authCode = document.getElementById('two-factor-totp-authcode').value;\n                let key = this.settings.totp_data.key;\n                let selectedProvider = this.getCheckedInputValue('preferred_method');\n                let sendData = {\n                    'two-factor-totp-authcode': authCode,\n                    provider: selectedProvider,\n                    key: key,\n                    redirect_to: this.settings.redirect_to,\n                    user_id: this.settings.user_id,\n                    login_nonce: this.settings.login_nonce\n                };\n                try {\n                    let response = await this.performFetchOp('/save_default_method_totp', sendData);\n                    if (!response.ok) {\n                        let error = await response.json();\n                            this.displayTwoFaOnboardingError(error.error);\n                    } else {\n                        let data = await response.json();\n                        window.location.href = data.redirect_to;\n                    }\n                } catch (error) {\n                    this.logFetchError(error);\n                }\n            });\n        }\n\n        let resendButton = this.getElement('rsssl-two-factor-email-code-resend');\n        if (resendButton !== null) {\n            resendButton.addEventListener('click', (event) => {\n                event.preventDefault();\n                const data = {\n                    user_id: this.settings.user_id,\n                    login_nonce: this.settings.login_nonce,\n                    provider: 'email'\n                };\n                this.performFetchOp('/resend_email_code', data)\n                    .then(response => {\n                        return response.json()\n                            .then(responseData => {\n                                if (!response.ok) {\n                                    this.displayTwoFaOnboardingError(responseData.error || responseData.message);\n                                } else {\n                                    this.clearTwoFactorPrompt();\n                                    this.displayTwoFaOnboardingSuccess(responseData.message);\n                                }\n                            })\n                            .catch(jsonErr => {\n                                console.error('Invalid JSON response:', jsonErr);\n                            });\n                    })\n                    .catch(err => {\n                        this.logFetchError(err);\n                    });\n            });\n        }\n\n        let downloadButton = this.getElement('download_codes');\n\n        downloadButton.addEventListener('click', (e) => {\n            e.preventDefault();\n            this.download_codes();\n        });\n\n        let passkeySubmit = this.getElement('rsssl-register-passkey'); // New Passkey submission handling\n        if (passkeySubmit !== null) {\n            passkeySubmit.addEventListener('click', (event) => {\n                event.preventDefault();\n            });\n        }\n\n        this.getElement('two-factor-qr-code').addEventListener('click', function (e) {\n            e.preventDefault();\n            that.copyTextAndShowMessage();\n        });\n\n        this.getElement('totp-key').addEventListener('click', function (e) {\n            e.preventDefault();\n            that.copyTextAndShowMessage();\n        });\n        if (document.readyState === 'complete') {\n            this.qr_generator();\n\n        } else {\n            this.qr_generator();\n        }\n    }\n\n    displayTwoFaOnboardingError(error) {\n        let loginForm = document.getElementById('two_fa_onboarding_form');\n        if (loginForm) {\n            let errorDiv = document.getElementById('login-message');\n            if(!errorDiv) {\n                errorDiv = document.createElement('div');\n                errorDiv.id = 'login-message';\n                errorDiv.className = 'notice notice-error message';\n                loginForm.insertAdjacentElement('beforebegin', errorDiv);\n            }\n            errorDiv.innerHTML = `<p>${error}</p>`;\n            setTimeout(() => {\n                // removing the error box from the loginForm\n                errorDiv.remove();\n            }, 5000);\n        }\n    }\n\n    displayTwoFaOnboardingSuccess(message) {\n        let loginForm = document.getElementById('two_fa_onboarding_form');\n        if (loginForm) {\n            let messageDiv = document.getElementById('login-message-success');\n            if (!messageDiv) {\n                messageDiv = document.createElement('div');\n                messageDiv.id = 'login-message-success';\n                messageDiv.className = 'notice notice-success message';\n                loginForm.insertAdjacentElement('beforebegin', messageDiv);\n            }\n            messageDiv.innerHTML = `<p>${message}</p>`;\n            setTimeout(() => {\n                messageDiv.remove();\n            }, 5000);\n        }\n    }\n\n    clearTwoFactorPrompt() {\n        // Select elements by class name without the dot prefix\n        let elements = document.getElementsByClassName('two-factor-prompt');\n        for (let i = 0; i < elements.length; i++) {\n            // Clear the content of each element\n            elements[i].innerHTML = '';\n            // Optionally hide the element\n            elements[i].style.display = 'none';\n        }\n    }\n}\nexport default Onboarding;","\nimport BaseAuth from './BaseAuth';\nimport Passkey from \"./passkey\";\n\nclass Login_Passkey extends BaseAuth {\n\n    constructor(root, settings) {\n        super(root, settings);\n        this.root = root;\n        this.settings = settings;\n        this.passkey = new Passkey(root, settings);\n    }\n    init() {\n        // we get the element by name rsssl_validate_2fa_form\n        const form = document.getElementsByName('rsssl_validate_2fa_form');\n\n        if (!form.length) {\n            this.addPasskeyButton();\n        } else {\n            // We check if the passkey button is already added\n            const passkeyButton = document.getElementById('rsssl-passkey-button');\n            if (passkeyButton) {\n                // If it is, we we check if the data-autorun is enabled\n                if (passkeyButton.getAttribute('data-autorun') === 'enabled') {\n                    this.passkey.handlePasskeyLogin();\n                }\n            }\n        }\n    }\n\n    addPasskeyButton() {\n        const loginForm = document.getElementById('loginform');\n        if (loginForm) {\n            const submitButton = loginForm.querySelector('p.submit');\n            if (submitButton) {\n                const passkeyButtonContainer = document.createElement('div');\n                passkeyButtonContainer.id = 'rsssl-passkey-button-container';\n                passkeyButtonContainer.style.display = 'flex';\n                passkeyButtonContainer.style.justifyContent = 'center';\n                passkeyButtonContainer.style.alignItems = 'center';\n\n                const passkeyButton = document.createElement('button');\n                passkeyButton.id = 'passkey-login-button';\n                passkeyButton.className = 'button button-primary';\n                passkeyButton.innerText = this.settings.translatables.log_in_with_passkey;\n\n                const orDivider = document.createElement('div');\n                orDivider.className = 'or-divider';\n                orDivider.innerHTML = '<span>' + this.settings.translatables.or + '</span>';\n\n                // creating the lock icon\n                const lockIcon = document.createElement('span');\n                lockIcon.className = 'dashicons dashicons-lock';\n                lockIcon.style.marginRight = '5px';\n\n                // Add the lock icon to the passkey button before the text\n                passkeyButton.insertBefore(lockIcon, passkeyButton.firstChild);\n                passkeyButton.style.display = 'flex';\n                passkeyButton.style.alignItems = 'center';\n                passkeyButton.style.justifyContent = 'center';\n\n                // Insert the custom divider after the submit button\n                submitButton.parentNode.insertBefore(orDivider, submitButton.nextSibling);\n\n                passkeyButtonContainer.appendChild(passkeyButton);\n\n                // Append the passkey button after the custom divider\n                submitButton.parentNode.insertBefore(passkeyButtonContainer, orDivider.nextSibling);\n\n                // Error display below the passkey button\n                const errorContainer = document.createElement('div');\n                errorContainer.id = 'rsssl-passkey-error';\n                errorContainer.style.display = 'none';\n                errorContainer.style.color = 'red';\n                errorContainer.style.fontSize = '12px';\n                errorContainer.style.marginTop = '10px';\n                errorContainer.style.textAlign = 'center';\n                errorContainer.style.width = '100%';\n                errorContainer.style.wordWrap = 'break-word';\n                errorContainer.style.wordBreak = 'break-all';\n\n                // Move this line to ensure errorContainer is appended outside any flex elements\n                submitButton.parentNode.insertBefore(errorContainer, passkeyButtonContainer.nextSibling);\n\n                // Add event listener to the passkey button using an arrow function to maintain the context of 'this'\n                passkeyButton.addEventListener('click', (event) => {\n                    this.passkey.handlePasskeyLogin(event);\n                });\n            }\n        }\n    }\n}\nexport default Login_Passkey;\n","// Disable all beforeunload handlers to prevent \"Leave site?\" prompts\n(function() {\n    // Prevent any assignment to window.onbeforeunload\n    Object.defineProperty(window, 'onbeforeunload', {\n        configurable: true,\n        get() { return null; },\n        set() { /* no-op */ }\n    });\n    // Block registration of beforeunload event listeners\n    const origAddEventListener = EventTarget.prototype.addEventListener;\n    EventTarget.prototype.addEventListener = function(type, listener, options) {\n        if (type === 'beforeunload') {\n            return;\n        }\n        return origAddEventListener.call(this, type, listener, options);\n    };\n})();\n\nimport BaseAuth from \"./BaseAuth\";\n\nclass PasskeyTableManager extends BaseAuth {\n    removeUrl = '/webauthn_delete_credential';\n\n    init() {\n        this.tableContainer = document.getElementById('rsssl-passkey-table-container');\n        this.initEventListeners();\n\n        //  Now fetch & render your table\n        this.fetchDataAndRender();\n    }\n\n    initEventListeners() {\n        document.addEventListener('click', (event) => {\n            if (event.target.matches('.rsssl-remove-passkey')) {\n                this.handleRemove(event.target.dataset.deviceId);\n            }\n        });\n    }\n\n    renderPasskeyTable(rows) {\n        const tableHTML = this.buildTableRows(rows, rows.length);\n        const tableBody = document.getElementById('rsssl-passkey-list');\n        tableBody.innerHTML = tableHTML;\n    }\n\n    buildTableRows(rows, count) {\n        let output = '';\n        rows.forEach(row => {\n            output += `\n                <tr>\n                    <td>${row.authDeviceId}</td>\n                    <td>${row.created_at}</td>\n                    <td>${row.updated_at}</td>\n                    <td>\n                        <button type=\"button\" class=\"button rsssl-remove-passkey\" ${count === 1 ? 'disabled' : ''} data-device-id=\"${row.id}\" style=\"display:inline;\">Remove</button>\n                    </td>\n                </tr>\n            `;\n        });\n        return output;\n    }\n    fetchDataAndRender() {\n        return this.performFetchOp('/webauthn_get_all_credentials', {user_id: this.settings.user_id, login_nonce: this.settings.login_nonce})\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    this.renderPasskeyTable(data.data.rows);\n                } else {\n                    console.error('Failed to fetch passkey data:', data);\n                }\n            })\n            .catch(this.logFetchError);\n    }\n\n    handleRemove(entry_id) {\n        this.performFetchOp(this.removeUrl, {entry_id: entry_id, user_id: this.settings.user_id, provider: 'passkey', login_nonce: this.settings.login_nonce})\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    this.fetchDataAndRender();\n                } else {\n                    console.error('Failed to remove passkey:', data);\n                }\n            })\n            .catch(this.logFetchError);\n    }\n\n    logFetchError(error) {\n        console.error('Fetch error:', error);\n    }\n}\n\nexport default PasskeyTableManager;","import {client} from '@passwordless-id/webauthn';\nimport BaseAuth from './BaseAuth';\nimport base64url from 'base64url';\nimport {Decoder as cbor} from \"cbor\";\nimport PasskeyTableManager from \"./passkey-table-manager\";\n\nconst BUTTON_CLASSES = {\n    pending: ['success', 'failed', 'login', 'login-failed'],\n    success: ['pending', 'failed', 'login', 'login-failed'],\n    failed: ['pending', 'success', 'login', 'login-failed'],\n    login: ['pending', 'success', 'failed', 'login-failed'],\n    'login-failed': ['pending', 'success', 'failed', 'login'],\n};\n\nconst knownAuthenticators = {\n    'ea9b8d664d011d213ce4b6b48cb575d4': 'Google Password Manager',\n    'adce000235bcc60a648b0b25f1f05503': 'Chrome on Mac',\n    '08987058cadc4b81b6e130de50dcbe96': 'Windows Hello',\n    '9ddd1817af5a4672a2b93e3dd95000a9': 'Windows Hello',\n    '6028b017b1d44c02b4b3afcdafc96bb2': 'Windows Hello',\n    'dd4ec289e01d41c9bb8970fa845d4bf2': 'iCloud Keychain (Managed)',\n    '531126d6e717415c93203d9aa6981239': 'Dashlane',\n    'bada5566a7aa401fbd9645619a55120d': '1Password',\n    'b84e404815dc4dd08640f4f60813c8af': 'NordPass',\n    '0ea242b443c44a1b8b17dd6d0b6baec6': 'Keeper',\n    '891494da2c904d31a9cd4eab0aed1309': 'Ssame',\n    'f38095407f1449c1a8b38f813b225541': 'Enpass',\n    'b53976664885aa6bcebf-e52262a439a2': 'Chromium Browser',\n    '771b48fdd3d44f749232fc157ab0507a': 'Edge on Mac',\n    '39a5647e1853446ca1f6a79bae9f5bc7': 'IDmelon',\n    'd548826e79b4db40a3d811116f7e8349': 'Bitwarden',\n    'fbfc3007154e4ecc8c0b6e020557d7bd': 'iCloud Keychain',\n    '53414d53554e47000000000000000000': 'Samsung Pass',\n    '66a0ccb3bd6a191fee06e375c50b9846': 'Thales Bio iOS SDK',\n    '8836336af5900921301d46427531eee6': 'Thales Bio Android SDK',\n    'cd69adb53c7adeb931776800ea6cb72a': 'Thales PIN Android SDK',\n    '17290f1ec21234d01423365d729f09d9': 'Thales PIN iOS SDK',\n    '50726f746f6e5061737350726f746f6e': 'Proton Pass',\n    'fdb141b25d84443e8a354698c205a502': 'KeePassXC',\n    'cc45f64e52a2451b831a4edd8022a202': 'ToothPic Passkey Provider'\n};\n\nclass Passkey extends BaseAuth {\n    constructor(root, settings) {\n        super(root, settings);\n        this.passkey = '';\n        this.onboarding = false;\n        this.manager = new PasskeyTableManager(this.root, this.settings);\n        this.translate = {\n            webauthn_not_available: this.settings.translatables.webauthn_not_available,\n            unknown_error: this.settings.translatables.unknown_error,\n            response_error: this.settings.translatables.response_error,\n            passkey_not_found: this.settings.translatables.passkey_not_found,\n            passkey_login_error: this.settings.translatables.passkey_login_error,\n            passkey_registration_error: this.settings.translatables.passkey_registration_error,\n            passkey_login_success: this.settings.translatables.passkey_login_success,\n            passkey_configuration: this.settings.translatables.passkey_configuration,\n            error_assertion: this.settings.translatables.error_assertion,\n            notice_inform: this.settings.translatables.notice_inform,\n            register_passkey: this.settings.translatables.register_passkey,\n            network_not_ok: this.settings.translatables.network_not_ok,\n            error_complete_registration: this.settings.translatables.error_complete_registration,\n            usb: this.settings.translatables.usb,\n            nfc: this.settings.translatables.nfc,\n            ble: this.settings.translatables.ble,\n            internal: this.settings.translatables.internal,\n            cross_platform: this.settings.translatables.cross_platform,\n            unknown: this.settings.translatables.unknown,\n            pending: this.settings.translatables.pending,\n            success: this.settings.translatables.success,\n            login: this.settings.translatables.login,\n            login_failed: this.settings.translatables.login_failed,\n            passkey_configure_manual_login: this.settings.translatables.passkey_configure_manual_login,\n        }\n        this.BUTTON_TEXT = {\n            pending: this.settings.translatables.pending,\n            success: this.settings.translatables.success,\n            failed: this.settings.translatables.failed,\n            login: this.settings.translatables.login,\n            'login-failed': this.settings.translatables.login_failed,\n        };\n    }\n\n    init() {\n        const stepThree = this.getElement('rsssl_step_three_onboarding');\n\n        if (stepThree !== null) {\n            const observer = new MutationObserver(this.handleMutation.bind(this));\n            observer.observe(stepThree, {attributes: true});\n        }\n\n        if (document.getElementById('rsssl-add-passkey-button')) {\n            this.assignClickListener('rsssl-add-passkey-button', this.handlePasskeyRegister.bind(this));\n        }\n    }\n\n    handleMutation(mutations) {\n        mutations.forEach((mutation) => {\n            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {\n                const displayStyle = window.getComputedStyle(mutation.target).display;\n                if (displayStyle === 'block') {\n                    this.showPasskeyOptions();\n                }\n            }\n        });\n    }\n\n    logButtonState = (id) => {\n        return document.getElementById(id);\n    }\n    updateRegisterButtonState(state) {\n        setTimeout(() => {\n            let workButton = this.logButtonState('register-passkey-button')\n                || this.logButtonState('rsssl-passkey-button')\n                || this.logButtonState('rsssl-add-passkey-button');\n            if (!workButton) return;\n\n            workButton.innerHTML = this.BUTTON_TEXT[state] || 'Unknown State';\n            workButton.disabled = state === 'pending';\n            workButton.classList.remove(...(BUTTON_CLASSES[state] || []));\n            workButton.classList.add(state);\n            // If login failed on the passkey button, make click retry the login challenge\n            if (state === 'login-failed' && workButton.id === 'rsssl-passkey-button') {\n                workButton.type = 'button';\n                workButton.addEventListener('click', e => {\n                    e.preventDefault();\n                    this.handlePasskeyLogin();\n                });\n            }\n            if (!this.BUTTON_TEXT[state]) {\n                console.error('Unknown state:', state);\n            }\n        }, 100); // Adjust the timeout duration as necessary\n    }\n\n    async handlePasskeyLogin() {\n        this.updateRegisterButtonState('login');\n\n        if (!client.isAvailable()) {\n            this.handleError(this.translate.webauthn_not_available, 'login-failed');\n            return;\n        }\n\n        try {\n            const userHandle = localStorage.getItem('webauthn_user_handle');\n            const userNameElement = document.getElementById('user_login');\n            const user_login = userNameElement ? userNameElement.value : '';\n            const requestData = {credentials: 'include', userHandle, user_login};\n\n            const response = await this.performFetchOp('/webauthn_challenge_assertion', requestData);\n\n            if (!response.ok) {\n                if (response.status === 400) {\n                    try {\n                        const errorData = await response.json();\n                        if (errorData && errorData.error) {\n                            this.handleError(errorData.error, 'login-failed');\n                        } else {\n                            this.handleError(this.translate.passkey_configure_manual_login, 'login-failed');\n                        }\n                    } catch (jsonError) {\n                        this.handleError(this.translate.passkey_configure_manual_login, 'login-failed');\n                    }\n                    return;\n                }\n                // Handle other non-OK responses\n                try {\n                    const errorData = await response.json(); \n                    if (errorData && errorData.error) {\n                        this.handleError(errorData.error, 'login-failed');\n                    } else {\n                        this.handleError(this.translate.unknown_error, 'login-failed'); \n                    }\n                } catch (error) {\n                    console.error('Failed to parse JSON from other error response or unknown error:', error);\n                    this.handleError(this.translate.response_error, 'login-failed');\n                }\n                return; // Ensure we exit after handling non-OK responses\n            }\n            const publicKeyCredentialRequestOptions = await this.prepareCredentialRequest(response, userHandle);\n            const assertion = await navigator.credentials.get({publicKey: publicKeyCredentialRequestOptions});\n            await this.sendAssertion(assertion);\n        } catch (error) {\n            if (error.name === 'NotAllowedError') {\n                this.handleError(this.translate.passkey_not_found, 'login-failed');\n            } else {\n                this.handleError(this.translate.passkey_login_error, 'login-failed', error);\n            }\n        }\n    }\n\n    async prepareCredentialRequest(response, userHandle) {\n        const options = await response.json();\n        options.challenge = base64url.toBuffer(options.challenge);\n\n        if (options.allowCredentials) {\n            options.allowCredentials = options.allowCredentials.map(cred => ({\n                ...cred,\n                id: base64url.toBuffer(cred.id),\n            }));\n        }\n\n        if (userHandle) {\n            options.userHandle = base64url.toBuffer(userHandle);\n        }\n\n        return options;\n    }\n\n    async sendAssertion(assertion) {\n        const data = {\n            credential: {\n                id: assertion.id,\n                rawId: base64url.encode(assertion.rawId),\n                response: {\n                    authenticatorData: base64url.encode(assertion.response.authenticatorData),\n                    clientDataJSON: base64url.encode(assertion.response.clientDataJSON),\n                    signature: base64url.encode(assertion.response.signature),\n                    userHandle: base64url.encode(assertion.response.userHandle),\n                },\n                type: assertion.type,\n            },\n            onboarding: this.onboarding,\n            redirect_to: this.settings.redirect_to,\n        };\n\n        try {\n            console.log('Attempting /webauthn_verify_assertion with data:', data);\n            const response = await this.performFetchOp('/webauthn_verify_assertion', data);\n            \n            if (!response.ok) {\n                console.log('/webauthn_verify_assertion failed with status:', response.status);\n                if (response.status === 400) {\n                    console.log('Handling 400 error from /webauthn_verify_assertion');\n                    try {\n                        const errorData = await response.json();\n                        if (errorData && errorData.error) {\n                            console.log('400 error data from verify_assertion:', errorData);\n                            this.handleError(errorData.error, 'login-failed');\n                        } else {\n                            console.log('400 error from verify_assertion, but no specific error message in JSON. Falling back to manual configure message.');\n                            this.handleError(this.translate.passkey_configure_manual_login, 'login-failed');\n                        }\n                    } catch (jsonError) {\n                        console.error('Failed to parse JSON from 400 error response (verify_assertion):', jsonError);\n                        this.handleError(this.translate.passkey_configure_manual_login, 'login-failed');\n                    }\n                } else {\n                    // Handle other non-400 errors for verify_assertion\n                    const result = await response.json(); // Attempt to parse for other errors too\n                    console.log('Error during /webauthn_verify_assertion, result:', result);\n                    this.handleError(result.message || this.translate.error_assertion, 'login-failed');\n                }\n                return; // Exit after handling error\n            }\n\n            // If response.ok is true\n            const result = await response.json();\n            console.log('/webauthn_verify_assertion response result:', result);\n\n            if (result.status === 'success') {\n                this.updateRegisterButtonState('success');\n                if (result.redirect_to.includes('rsssl_no_redirect')) {\n                    this.manager.fetchDataAndRender();\n                } else {\n                    const form = document.querySelector('form');\n                    if (form) {\n                        form.reset();\n                    }\n                    window.onbeforeunload = null;\n                    window.location.href = result.redirect_to;\n                }\n            } else {\n                this.updateRegisterButtonState('login-failed');\n            }\n        } catch (error) {\n            console.error('Error in sendAssertion catch block:', error);\n            this.handleError(this.translate.error_assertion, 'login-failed', error);\n        }\n    }\n\n    showPasskeyOptions() {\n        // first we change the h3 text and the p text with the instructions\n        const mainElement = this.getElement('two_fa_onboarding_form');\n        if (mainElement) {\n            mainElement.querySelector('h3').innerText = this.settings.translatables.passkey_configuration;\n            document.querySelector('.rsssl_into_two_factor').innerHTML = this.settings.translatables.notice_inform;\n        }\n        // this.getElement('rsssl_step_three_onboarding').getElement('rsssl_into_two_factor').innerText = 'rsssl_into_two_factor';\n        let container = this.getElement('passkey-integration');\n        if (!container) {\n            container = document.createElement('div');\n            container.id = 'passkey-integration';\n            document.body.appendChild(container);\n        }\n\n        container.innerHTML = `<button id=\"register-passkey-button\" class=\"passkey-registration-button\">${this.settings.translatables.register_passkey}</button>`;\n        this.assignClickListener('register-passkey-button', this.handlePasskeyRegister.bind(this));\n    }\n\n    async handlePasskeyRegister() {\n        // We prevent the default behavior of the button to avoid form submission\n        this.updateRegisterButtonState('pending');\n        if (!client.isAvailable()) {\n            this.handleError(this.settings.translatables.webauthn_not_available, 'failed');\n            return;\n        }\n\n        try {\n            const publicKeyCreationOptions = await this.fetchPublicKeyOptions();\n            const credential = await navigator.credentials.create({publicKey: publicKeyCreationOptions});\n            const registrationResult = await this.completeRegistration(credential);\n            if (registrationResult.status !== 'success') {\n                this.updateRegisterButtonState('failed');\n            }\n            if (registrationResult.redirect_to.includes('rsssl_no_redirect')) {\n                // we reload the page to show the new profile\n                const form = document.querySelector('form');\n                if (form) {\n                    form.reset();\n                }\n                window.onbeforeunload = null;\n                window.location.reload();\n            } else {\n                const form = document.querySelector('form');\n                if (form) {\n                    form.reset();\n                }\n                window.onbeforeunload = null;\n                window.location.href = registrationResult.redirect_to;\n            }\n        } catch (error) {\n            this.handleError(this.translate.error_complete_registration, 'failed', error);\n        }\n    }\n\n    async fetchPublicKeyOptions() {\n        const response = await this.performFetchOp('/webauthn_register_callback', {\n            user_id: this.settings.user_id,\n            login_nonce: this.settings.login_nonce,\n            provider: 'passkey_register',\n        });\n\n        if (!response.ok) throw new Error(this.translate.network_not_ok);\n\n        const options = await response.json();\n\n        base64url.toBuffer(this.generateUniqueUserHandle());\n        options.challenge = base64url.toBuffer(options.challenge); // challenge as Uint8Array\n        options.user.id = base64url.toBuffer(options.user.id); // user.id as Uint8Array\n        options.user.name = this.settings.display_name || options.user.name;\n        options.user.displayName = this.settings.display_name || options.user.displayName;\n        options.pubKeyCredParams = [{type: 'public-key', alg: -7}, {type: 'public-key', alg: -257}];\n        options.rp.id = window.location.hostname;\n        options.authenticatorSelection = {authenticatorAttachment: 'platform', userVerification: 'preferred'};\n\n        return options;\n    }\n\n    async completeRegistration(credential) {\n        const deviceName = this.getDeviceName(credential);\n\n        const data = {\n            credential: {\n                id: credential.id,\n                rawId: base64url.encode(credential.rawId),\n                response: {\n                    attestationObject: base64url.encode(credential.response.attestationObject),\n                    clientDataJSON: base64url.encode(credential.response.clientDataJSON),\n                },\n                type: credential.type,\n                authDevice: deviceName,\n            },\n            user_id: this.settings.user_id,\n            redirect_to: this.settings.redirect_to,\n            device_name: deviceName,\n            login_nonce: this.settings.login_nonce,\n        };\n\n        try {\n            const response = await this.performFetchOp('/webauthn_complete_registration', data);\n            const result = await response.json();\n\n            if (response.ok && result.status === 'success') {\n                if (result.userHandle) {\n                    localStorage.setItem('webauthn_user_handle', result.userHandle);\n                }\n                this.updateRegisterButtonState('success');\n                this.onboarding = true;\n                await this.handlePasskeyLogin();\n                return {status: 'success', redirect_to: result.redirect_to};\n            } else {\n                return {status: 'failed', reason: 'registration_failed'};\n            }\n        } catch (error) {\n            this.handleError(this.translate.error_complete_registration, 'failed', error);\n            return {status: 'failed', reason: 'error_occurred'};\n        }\n    }\n\n    async fireRegistration(automatic = true) {\n        if (automatic) {\n            const result = await this.handlePasskeyRegister();\n            this.updateRegisterButtonState(result.status === 'success' ? 'success' : 'failed');\n        } else {\n            this.assignClickListener('register-passkey-button', this.handlePasskeyRegister.bind(this));\n        }\n    }\n\n    handleError(message, state, error = null) {\n        this.updateRegisterButtonState(state);\n        // show the error message in the error container\n        const errorContainer = this.getElement('rsssl-passkey-error');\n        if (errorContainer) {\n            errorContainer.innerText = message;\n            errorContainer.style.display = 'block';\n        }\n        console.error(message, error);\n    }\n\n    getDeviceName(credential) {\n        let deviceName = 'unknown';\n        let authenticatorAttachment = credential.authenticatorAttachment || 'unknown';\n\n        const attestationObject = credential.response.attestationObject;\n\n        // Decode the attestation object\n        const decodedAttestationObject = cbor.decodeAllSync(new Uint8Array(attestationObject))[0];\n        const authData = new Uint8Array(decodedAttestationObject.authData);\n\n        // Extract the aaguid (bytes 37-52 of authData)\n        const aaguid = authData.slice(37, 53);\n        const aaguidString = Array.from(aaguid).map(byte => byte.toString(16).padStart(2, '0')).join('');\n        if (knownAuthenticators[aaguidString]) {\n            return knownAuthenticators[aaguidString];\n        }\n\n        if (typeof credential.response.getTransports === 'function') {\n            const transports = credential.response.getTransports();\n            if (transports && transports.length > 0) {\n                authenticatorAttachment = transports[0]; // Use the first available transport method\n            }\n        }\n\n        switch (authenticatorAttachment) {\n            case 'usb':\n                deviceName = this.settings.translatables.usb;\n                break;\n            case 'nfc':\n                deviceName = this.settings.translatables.nfc;\n                break;\n            case 'ble':\n                deviceName = this.settings.translatables.ble;\n                break;\n            case 'internal':\n                deviceName = this.settings.translatables.internal;\n                break;\n            case 'cross-platform':\n                deviceName = this.settings.translatables.cross_platform;\n                break;\n            default:\n                deviceName = this.settings.translatables.unknown;\n        }\n        return deviceName;\n    }\n\n    generateUniqueUserHandle() {\n        return `${this.settings.user_id}-${Date.now()}`;\n    }\n}\nexport default Passkey;","import BaseAuth from './BaseAuth'\nimport Passkey from \"./passkey\";\n\nclass Profile extends BaseAuth {\n    init() {\n\n        this.assignClickListener('download_codes', this.download_codes);\n        this.assignClickListener('two-factor-qr-code', this.copyTextAndShowMessage);\n        this.assignClickListener('totp-key', this.copyTextAndShowMessage);\n\n        const qrCodeContainer = this.getElement('qr-code-container');\n        const enableCheckbox = this.getElement('two-factor-authentication');\n        const tableRowSelection = this.getElement('selection_two_fa');\n        const methodSelection = document.querySelectorAll('input[name=\"preferred_method\"]');\n        const validationEmail = document.getElementById('rsssl_verify_email');\n        const change2faConfig = this.getElement('change_2fa_config');\n        const passKeyContainer = this.getElement('rsssl_step_three_onboarding');\n        const passkeySection = this.getElement('passkey-table');\n        this.passkey = new Passkey(this.root, this.settings);\n        // Temporarily disable WP beforeunload handler to avoid \"Leave site?\" prompt on load\n        const origBeforeUnload = window.onbeforeunload;\n        window.onbeforeunload = null;\n        this.passkey.init();\n        // Restore WP beforeunload handler after passkey UI initialization\n        window.onbeforeunload = origBeforeUnload;\n        // Clear WordPress unsaved-changes flag by dispatching a reset event on the profile form\n        const profileForm = document.getElementById('your-profile');\n        if (profileForm) {\n            profileForm.dispatchEvent(new Event('reset'));\n        }\n        let that = this;\n        const thereIsAnAddDevice = document.getElementById('rsssl_add_device');\n        if (thereIsAnAddDevice) {\n            that.passkey.fireRegistration(false).then(r => {\n                if (r) {\n                    this.getElement('rsssl_step_three_onboarding').style.display = 'none';\n                    this.getElement('rsssl_step_four_onboarding').style.display = 'block';\n                }\n            });\n        }\n        if (qrCodeContainer) {\n            qrCodeContainer.style.display = \"none\";\n            if (!enableCheckbox.checked) {\n                tableRowSelection.style.display = \"none\";\n                qrCodeContainer.style.display = \"none\";\n            }\n        }\n        if(enableCheckbox) {\n            let parent = this;\n            enableCheckbox.addEventListener(\"change\", function () {\n                if (this.checked) {\n                    tableRowSelection.style.display = \"table-row\";\n                    let selectedMethod = document.querySelector('input[name=\"preferred_method\"]:checked');\n                    if (selectedMethod && selectedMethod.value === \"totp\") {\n                        qrCodeContainer.style.display = \"block\";\n                        parent.qr_generator();\n                    } else {\n                        qrCodeContainer.style.display = \"none\";\n                    }\n                } else {\n                    tableRowSelection.style.display = \"none\";\n                    qrCodeContainer.style.display = \"none\";\n                    let selectedMethod = document.querySelector('input[name=\"preferred_method\"]:checked');\n                    selectedMethod.value = \"none\";\n                }\n            });\n        }\n\n        if(methodSelection.length > 0 ) {\n            let parent = this;\n            methodSelection.forEach(function (element) {\n                element.addEventListener(\"change\", function () {\n                    let selectedMethod = document.querySelector('input[name=\"preferred_method\"]:checked').value;\n                    if (selectedMethod === \"totp\") {\n                        if(validationEmail) {\n                            validationEmail.style.display = \"none\";\n                        }\n                        qrCodeContainer.style.display = \"block\";\n                        parent.qr_generator();\n                    } else if(selectedMethod === \"email\") {\n                        qrCodeContainer.style.display = \"none\";\n                        if(validationEmail) {\n                            validationEmail.style.display = \"table-row\";\n                        }\n                        let data = {\n                            action: 'change_method_to_email',\n                            provider: selectedMethod,\n                            user_id: rsssl_profile.user_id,\n                            login_nonce: document.getElementById('rsssl_two_fa_nonce').value,\n                            redirect_to: rsssl_profile.redirect_to,\n                            profile: true\n                        };\n                        fetch(rsssl_profile.ajax_url, {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'\n                            },\n                            body: new URLSearchParams(data)\n                        })\n                            .then(response => response.json())\n                            .then(responseData => {\n                                // Expected structure: { success: true, data: { message: \"Verification code sent\", token: ... } }\n                                let errorDiv = document.getElementById('login-message');\n                                let inPutField = document.getElementById('rsssl-two-factor-email-code');\n                                if (inPutField) {\n                                    if (!errorDiv) {\n                                        errorDiv = document.createElement('p');\n                                        errorDiv.classList.add('notice', 'notice-success');\n                                        inPutField.insertAdjacentElement('afterend', errorDiv);\n                                    }\n                                    // Use the message returned from your PHP callback\n                                    if (responseData.data.message) {\n                                        errorDiv.innerHTML = `<p>${responseData.data.message}</p>`;\n                                    } else {\n                                        console.error('No message returned from the server.');\n                                    }\n                                    // Optionally, do something with responseData.data.token if needed.\n                                    setTimeout(() => {\n                                        errorDiv.remove();\n                                    }, 5000);\n                                }\n                            })\n                            .catch(that.logFetchError);\n                    }else if (selectedMethod === \"passkey\") {\n                        qrCodeContainer.style.display = \"none\";\n                        passKeyContainer.style.display = \"block\";\n                        passkeySection.style.opacity = \"1\";\n                        that.passkey.fireRegistration().then(r => {\n                            if (r) {\n                                this.getElement('rsssl_step_three_onboarding').style.display = 'none';\n                                this.getElement('rsssl_step_four_onboarding').style.display = 'block';\n                            }\n                        });\n                    } else {\n                        qrCodeContainer.style.display = \"none\";\n                    }\n                });\n            });\n        }\n\n        let resendButton = this.getElement('rsssl_resend_code_action');\n        if(resendButton !== null) {\n            resendButton.addEventListener('click', (event) => {\n                event.preventDefault();\n                let data = {\n                    action: 'resend_email_code_profile',\n                    user_id: this.settings.user_id,\n                    login_nonce: document.getElementById('rsssl_two_fa_nonce').value,\n                    provider: 'email',\n                    profile: true\n                };\n                let ajaxUrl = rsssl_profile.ajax_url;\n                fetch(ajaxUrl, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'\n                    },\n                    body: new URLSearchParams(data)\n                })\n                    .then(response => response.json())\n                    .then(responseData => {\n                        // responseData will have the structure: { success: true, data: { message: \"...\" } }\n                        let errorDiv = document.getElementById('login-message');\n                        let inPutField = document.getElementById('rsssl-two-factor-email-code');\n                        if (inPutField) {\n                            if (!errorDiv) {\n                                errorDiv = document.createElement('p');\n                                errorDiv.classList.add('notice', 'notice-success');\n                                inPutField.insertAdjacentElement('afterend', errorDiv);\n                            }\n                            errorDiv.innerHTML = `<p>${responseData.data.message}</p>`;\n                            // Fade out the message after 5 seconds.\n                            setTimeout(() => {\n                                errorDiv.remove();\n                            }, 5000);\n                        }\n                    })\n                    .catch(this.logFetchError);\n            });\n        }\n\n\n        if (change2faConfig) {\n            change2faConfig.addEventListener('click', function (e) {\n                e.preventDefault();\n                let inputField = document.createElement('input');\n                inputField.setAttribute('type', 'hidden');\n                inputField.setAttribute('name', 'change_2fa_config_field');\n                inputField.setAttribute('value', 'true');\n                document.getElementById('change_2fa_config').insertAdjacentElement('afterend', inputField);\n                // we uncheck Enable Two-Factor Authentication\n                let enableCheckbox = document.getElementById(\"two-factor-authentication\");\n                enableCheckbox.checked = false;\n                let profileForm = document.getElementById('your-profile');\n                if (profileForm) {\n                    profileForm.requestSubmit();\n                }\n            });\n        }\n    }\n    fetchPasskeyData() {\n        const urlExtension = '/webauthn_get_all_credentials';\n        const data = {\n            nonce: this.settings.nonce,\n            user_id: this.settings.user_id,\n            user: this.settings.user,\n            provider: 'passkey',\n            login_nonce: document.getElementById('rsssl_two_fa_nonce').value,\n        };\n\n        this.performFetchOp(urlExtension, data)\n            .then(response => response.json())\n            .then(data => {\n                if (data.success) {\n                    this.renderPasskeyTable(data.data.rows);\n                } else {\n                    console.error('Failed to fetch passkey data:', data);\n                }\n            })\n            .catch(this.logFetchError);\n    }\n\n    renderPasskeyTable(rows) {\n        const tableBody = this.getElement('the-list'); // Replace with your actual table body ID\n        tableBody.innerHTML = 'bakfiets';\n        // Create HTML string from rows array\n        tableBody.innerHTML = rows.map(row => `\n        <tr>\n            <td>${row.device_name}</td>\n            <td>${row.registered}</td>\n            <td>${row.last_used}</td>\n            <td>${row.actions}</td>\n        </tr>\n    `).join('');\n    }\n}\n\nexport default Profile;","import BaseAuth from \"./BaseAuth\";\nimport Passkey from \"./passkey\";\n\nclass Validate extends BaseAuth {\n    constructor(root, settings) {\n        super(root, settings);\n        this.root = root;\n        this.settings = settings;\n        this.passkey = new Passkey(this.root, this.settings);\n    }\n\n    init() {\n        this.passkey.init();\n        //Validate button\n        const validateButton = document.getElementById('rsssl-passkey-button');\n        if (validateButton) {\n            validateButton.addEventListener('click', (event) => {\n                event.preventDefault();\n                this.passkey.handlePasskeyLogin(event);\n            });\n        }\n    }\n}\n\nexport default Validate;","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n","module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","'use strict'\n\nconst Commented = require('./commented')\nconst Diagnose = require('./diagnose')\nconst Decoder = require('./decoder')\nconst Encoder = require('./encoder')\nconst Simple = require('./simple')\nconst Tagged = require('./tagged')\nconst Map = require('./map')\nconst SharedValueEncoder = require('./sharedValueEncoder')\n\nmodule.exports = {\n  Commented,\n  Diagnose,\n  Decoder,\n  Encoder,\n  Simple,\n  Tagged,\n  Map,\n  SharedValueEncoder,\n\n  /**\n   * Convenience name for {@linkcode Commented.comment}.\n   */\n  comment: Commented.comment,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAll}.\n   */\n  decodeAll: Decoder.decodeAll,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirst}.\n   */\n  decodeFirst: Decoder.decodeFirst,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeAllSync}.\n   */\n  decodeAllSync: Decoder.decodeAllSync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decodeFirstSync: Decoder.decodeFirstSync,\n\n  /**\n   * Convenience name for {@linkcode Diagnose.diagnose}.\n   */\n  diagnose: Diagnose.diagnose,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encode}.\n   */\n  encode: Encoder.encode,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeCanonical}.\n   */\n  encodeCanonical: Encoder.encodeCanonical,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeOne}.\n   */\n  encodeOne: Encoder.encodeOne,\n\n  /**\n   * Convenience name for {@linkcode Encoder.encodeAsync}.\n   */\n  encodeAsync: Encoder.encodeAsync,\n\n  /**\n   * Convenience name for {@linkcode Decoder.decodeFirstSync}.\n   */\n  decode: Decoder.decodeFirstSync,\n\n  /**\n   * The codec information for\n   * {@link https://github.com/Level/encoding-down encoding-down}, which is a\n   * codec framework for leveldb.  CBOR is a particularly convenient format for\n   * both keys and values, as it can deal with a lot of types that JSON can't\n   * handle without losing type information.\n   *\n   * @example\n   * const level = require('level')\n   * const cbor = require('cbor')\n   *\n   * async function putget() {\n   *   const db = level('./db', {\n   *     keyEncoding: cbor.leveldb,\n   *     valueEncoding: cbor.leveldb,\n   *   })\n   *\n   *   await db.put({a: 1}, 9857298342094820394820394820398234092834n)\n   *   const val = await db.get({a: 1})\n   * }\n   */\n  leveldb: {\n    decode: Decoder.decodeFirstSync,\n    encode: Encoder.encode,\n    buffer: true,\n    name: 'cbor',\n  },\n\n  /**\n   * Reset everything that we can predict a plugin might have altered in good\n   * faith.  For now that includes the default set of tags that decoding and\n   * encoding will use.\n   */\n  reset() {\n    Encoder.reset()\n    Tagged.reset()\n  },\n}\n","'use strict'\n\nconst stream = require('stream')\nconst utils = require('./utils')\nconst Decoder = require('./decoder')\nconst NoFilter = require('nofilter')\nconst {MT, NUMBYTES, SYMS} = require('./constants')\nconst {Buffer} = require('buffer')\n\nfunction plural(c) {\n  if (c > 1) {\n    return 's'\n  }\n  return ''\n}\n\n/**\n * @typedef CommentOptions\n * @property {number} [max_depth=10] How many times to indent\n *   the dashes.\n * @property {number} [depth=1] Initial indentation depth.\n * @property {boolean} [no_summary=false] If true, omit the summary\n *   of the full bytes read at the end.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] Encoding to use for input, if it\n *   is a string.\n */\n/**\n * @callback commentCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [commented] The comment string.\n * @returns {void}\n */\n/**\n * Normalize inputs to the static functions.\n *\n * @param {CommentOptions|commentCallback|string|number} opts Encoding,\n *   max_depth, or callback.\n * @param {commentCallback} [cb] Called on completion.\n * @returns {{options: CommentOptions, cb: commentCallback}} Normalized value.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {commentCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'number':\n      return {options: {max_depth: opts}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Generate the expanded format of RFC 8949, section 3.2.2.\n *\n * @extends stream.Transform\n */\nclass Commented extends stream.Transform {\n  /**\n   * Create a CBOR commenter.\n   *\n   * @param {CommentOptions} [options={}] Stream options.\n   */\n  constructor(options = {}) {\n    const {\n      depth = 1,\n      max_depth = 10,\n      no_summary = false,\n      // Decoder options\n      tags = {},\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.depth = depth\n    this.max_depth = max_depth\n    this.all = new NoFilter()\n\n    if (!tags[24]) {\n      tags[24] = this._tag_24.bind(this)\n    }\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('start-string', this._on_start_string.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n    if (!no_summary) {\n      this.parser.on('data', this._on_data.bind(this))\n    }\n    this.parser.bs.on('read', this._on_read.bind(this))\n  }\n\n  /**\n   * @param {Buffer} v Descend into embedded CBOR.\n   * @private\n   */\n  _tag_24(v) {\n    const c = new Commented({depth: this.depth + 1, no_summary: true})\n\n    c.on('data', b => this.push(b))\n    c.on('error', er => this.emit('error', er))\n    c.end(v)\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    // TODO: find the test that covers this, and look at the return value\n    return this.parser._flush(cb)\n  }\n\n  /**\n   * Comment on an input Buffer or string, creating a string passed to the\n   * callback.  If callback not specified, a promise is returned.\n   *\n   * @param {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n   *   |DataView|stream.Readable} input Something to parse.\n   * @param {CommentOptions|commentCallback|string|number} [options={}]\n   *   Encoding, max_depth, or callback.\n   * @param {commentCallback} [cb] If specified, called on completion.\n   * @returns {Promise} If cb not specified.\n   * @throws {Error} Input required.\n   * @static\n   */\n  static comment(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new Error('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const bs = new NoFilter()\n    const {encoding = 'hex', ...opts} = options\n    const d = new Commented(opts)\n    let p = null\n\n    if (typeof cb === 'function') {\n      d.on('end', () => {\n        cb(null, bs.toString('utf8'))\n      })\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => {\n          resolve(bs.toString('utf8'))\n        })\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    this.push('ERROR: ')\n    this.push(er.toString())\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_read(buf) {\n    this.all.write(buf)\n    const hex = buf.toString('hex')\n\n    this.push(new Array(this.depth + 1).join('  '))\n    this.push(hex)\n\n    let ind = ((this.max_depth - this.depth) * 2) - hex.length\n    if (ind < 1) {\n      ind = 1\n    }\n    this.push(new Array(ind + 1).join(' '))\n    this.push('-- ')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_more(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.POS_INT:\n        desc = 'Positive number,'\n        break\n      case MT.NEG_INT:\n        desc = 'Negative number,'\n        break\n      case MT.ARRAY:\n        desc = 'Array, length'\n        break\n      case MT.MAP:\n        desc = 'Map, count'\n        break\n      case MT.BYTE_STRING:\n        desc = 'Bytes, length'\n        break\n      case MT.UTF8_STRING:\n        desc = 'String, length'\n        break\n      case MT.SIMPLE_FLOAT:\n        if (len === 1) {\n          desc = 'Simple value,'\n        } else {\n          desc = 'Float,'\n        }\n        break\n    }\n    this.push(`${desc} next ${len} byte${plural(len)}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start_string(mt, len, parent_mt, pos) {\n    let desc = ''\n\n    this.depth++\n    switch (mt) {\n      case MT.BYTE_STRING:\n        desc = `Bytes, length: ${len}`\n        break\n      case MT.UTF8_STRING:\n        desc = `String, length: ${len.toString()}`\n        break\n    }\n    this.push(`${desc}\\n`)\n  }\n\n  /**\n   * @ignore\n   */\n  _on_start(mt, tag, parent_mt, pos) {\n    this.depth++\n    switch (parent_mt) {\n      case MT.ARRAY:\n        this.push(`[${pos}], `)\n        break\n      case MT.MAP:\n        if (pos % 2) {\n          this.push(`{Val:${Math.floor(pos / 2)}}, `)\n        } else {\n          this.push(`{Key:${Math.floor(pos / 2)}}, `)\n        }\n        break\n    }\n    switch (mt) {\n      case MT.TAG:\n        this.push(`Tag #${tag}`)\n        if (tag === 24) {\n          this.push(' Encoded CBOR data item')\n        }\n        break\n      case MT.ARRAY:\n        if (tag === SYMS.STREAM) {\n          this.push('Array (streaming)')\n        } else {\n          this.push(`Array, ${tag} item${plural(tag)}`)\n        }\n        break\n      case MT.MAP:\n        if (tag === SYMS.STREAM) {\n          this.push('Map (streaming)')\n        } else {\n          this.push(`Map, ${tag} pair${plural(tag)}`)\n        }\n        break\n      case MT.BYTE_STRING:\n        this.push('Bytes (streaming)')\n        break\n      case MT.UTF8_STRING:\n        this.push('String (streaming)')\n        break\n    }\n    this.push('\\n')\n  }\n\n  /**\n   * @ignore\n   */\n  _on_stop(mt) {\n    this.depth--\n  }\n\n  /**\n   * @private\n   */\n  _on_value(val, parent_mt, pos, ai) {\n    if (val !== SYMS.BREAK) {\n      switch (parent_mt) {\n        case MT.ARRAY:\n          this.push(`[${pos}], `)\n          break\n        case MT.MAP:\n          if (pos % 2) {\n            this.push(`{Val:${Math.floor(pos / 2)}}, `)\n          } else {\n            this.push(`{Key:${Math.floor(pos / 2)}}, `)\n          }\n          break\n      }\n    }\n    const str = utils.cborValueToString(val, -Infinity)\n\n    if ((typeof val === 'string') ||\n        (Buffer.isBuffer(val))) {\n      if (val.length > 0) {\n        this.push(str)\n        this.push('\\n')\n      }\n      this.depth--\n    } else {\n      this.push(str)\n      this.push('\\n')\n    }\n\n    switch (ai) {\n      case NUMBYTES.ONE:\n      case NUMBYTES.TWO:\n      case NUMBYTES.FOUR:\n      case NUMBYTES.EIGHT:\n        this.depth--\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  _on_data() {\n    this.push('0x')\n    this.push(this.all.read().toString('hex'))\n    this.push('\\n')\n  }\n}\n\nmodule.exports = Commented\n","'use strict'\n\n/**\n * @enum {number}\n */\nexports.MT = {\n  POS_INT: 0,\n  NEG_INT: 1,\n  BYTE_STRING: 2,\n  UTF8_STRING: 3,\n  ARRAY: 4,\n  MAP: 5,\n  TAG: 6,\n  SIMPLE_FLOAT: 7,\n}\n\n/**\n * @enum {number}\n */\nexports.TAG = {\n  DATE_STRING: 0,\n  DATE_EPOCH: 1,\n  POS_BIGINT: 2,\n  NEG_BIGINT: 3,\n  DECIMAL_FRAC: 4,\n  BIGFLOAT: 5,\n  BASE64URL_EXPECTED: 21,\n  BASE64_EXPECTED: 22,\n  BASE16_EXPECTED: 23,\n  CBOR: 24,\n  URI: 32,\n  BASE64URL: 33,\n  BASE64: 34,\n  REGEXP: 35,\n  MIME: 36,\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  SET: 258,\n}\n\n/**\n * @enum {number}\n */\nexports.NUMBYTES = {\n  ZERO: 0,\n  ONE: 24,\n  TWO: 25,\n  FOUR: 26,\n  EIGHT: 27,\n  INDEFINITE: 31,\n}\n\n/**\n * @enum {number}\n */\nexports.SIMPLE = {\n  FALSE: 20,\n  TRUE: 21,\n  NULL: 22,\n  UNDEFINED: 23,\n}\n\nexports.SYMS = {\n  NULL: Symbol.for('github.com/hildjj/node-cbor/null'),\n  UNDEFINED: Symbol.for('github.com/hildjj/node-cbor/undef'),\n  PARENT: Symbol.for('github.com/hildjj/node-cbor/parent'),\n  BREAK: Symbol.for('github.com/hildjj/node-cbor/break'),\n  STREAM: Symbol.for('github.com/hildjj/node-cbor/stream'),\n}\n\nexports.SHIFT32 = 0x100000000\n\nexports.BI = {\n  MINUS_ONE: BigInt(-1),\n  NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),\n  MAXINT32: BigInt('0xffffffff'),\n  MAXINT64: BigInt('0xffffffffffffffff'),\n  SHIFT32: BigInt(exports.SHIFT32),\n}\n\n","'use strict'\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream')\nconst Tagged = require('./tagged')\nconst Simple = require('./simple')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {MT, NUMBYTES, SYMS, BI} = constants\nconst {Buffer} = require('buffer')\n\nconst COUNT = Symbol('count')\nconst MAJOR = Symbol('major type')\nconst ERROR = Symbol('error')\nconst NOT_FOUND = Symbol('not found')\n\nfunction parentArray(parent, typ, count) {\n  const a = []\n\n  a[COUNT] = count\n  a[SYMS.PARENT] = parent\n  a[MAJOR] = typ\n  return a\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter()\n\n  b[COUNT] = -1\n  b[SYMS.PARENT] = parent\n  b[MAJOR] = typ\n  return b\n}\n\nclass UnexpectedDataError extends Error {\n  constructor(byte, value) {\n    super(`Unexpected data: 0x${byte.toString(16)}`)\n    this.name = 'UnexpectedDataError'\n    this.byte = byte\n    this.value = value\n  }\n}\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n/**\n * @typedef ExtendedResults\n * @property {any} value The value that was found.\n * @property {number} length The number of bytes of the original input that\n *   were read.\n * @property {Buffer} bytes The bytes of the original input that were used\n *   to produce the value.\n * @property {Buffer} [unused] The bytes that were left over from the original\n *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or\n *   {@linkcode Decoder.decodeFirstSync} was called.\n */\n/**\n * @typedef DecoderOptions\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferMap=false] If true, prefer to generate Map\n *   instances to plain objects, even if there are no entries in the map\n *   or if all of the keys are strings.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of the input.\n *   Ignored if input is a Buffer.\n * @property {boolean} [required=false] Should an error be thrown when no\n *   data is in the input?\n * @property {boolean} [extendedResults=false] If true, emit extended\n *   results, which will be an object with shape {@link ExtendedResults}.\n *   The value will already have been null-checked.\n * @property {boolean} [preventDuplicateKeys=false] If true, error is\n *   thrown if a map has duplicate keys.\n */\n/**\n * @callback decodeCallback\n * @param {Error} [error] If one was generated.\n * @param {any} [value] The decoded value.\n * @returns {void}\n */\n/**\n * @param {DecoderOptions|decodeCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {decodeCallback} [cb] Called on completion.\n * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.\n * @throws {TypeError} On unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {decodeCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends BinaryParseStream\n */\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {DecoderOptions} [options={}] Options.\n   */\n  constructor(options = {}) {\n    const {\n      tags = {},\n      max_depth = -1,\n      preferMap = false,\n      preferWeb = false,\n      required = false,\n      encoding = 'hex',\n      extendedResults = false,\n      preventDuplicateKeys = false,\n      ...superOpts\n    } = options\n\n    super({defaultEncoding: encoding, ...superOpts})\n\n    this.running = true\n    this.max_depth = max_depth\n    this.tags = tags\n    this.preferMap = preferMap\n    this.preferWeb = preferWeb\n    this.extendedResults = extendedResults\n    this.required = required\n    this.preventDuplicateKeys = preventDuplicateKeys\n\n    if (extendedResults) {\n      this.bs.on('read', this._onRead.bind(this))\n      this.valueBytes = /** @type {NoFilter} */ (new NoFilter())\n    }\n  }\n\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @param {any} val The value to check.\n   * @returns {any} The corrected value.\n   * @throws {Error} Nothing was found.\n   * @static\n   * @example\n   * myDecoder.on('data', val => {\n   *   val = Decoder.nullcheck(val)\n   *   // ...\n   * })\n   */\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null\n      case SYMS.UNDEFINED:\n        return undefined\n      // Leaving this in for now as belt-and-suspenders, but I'm pretty sure\n      // it can't happen.\n      /* istanbul ignore next */\n      case NOT_FOUND:\n        /* istanbul ignore next */\n        throw new Error('Value not found')\n      default:\n        return val\n    }\n  }\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw\n   * an exception if the input is not valid CBOR, or if there are more bytes\n   * left over at the end (if options.extendedResults is not true).\n   *\n   * @param {BufferLike} input If a Readable stream, must have\n   *   received the `readable` event already, or you will get an error\n   *   claiming \"Insufficient data\".\n   * @param {DecoderOptions|string} [options={}] Options or encoding for input.\n   * @returns {ExtendedResults|any} The decoded value.\n   * @throws {UnexpectedDataError} Data is left over after decoding.\n   * @throws {Error} Insufficient data.\n   * @static\n   */\n  static decodeFirstSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n\n    // For/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n    const parser = c._parse()\n    let state = parser.next()\n\n    while (!state.done) {\n      const b = s.read(state.value)\n\n      if ((b == null) || (b.length !== state.value)) {\n        throw new Error('Insufficient data')\n      }\n      if (c.extendedResults) {\n        c.valueBytes.write(b)\n      }\n      state = parser.next(b)\n    }\n\n    let val = null\n    if (c.extendedResults) {\n      val = state.value\n      val.unused = s.read()\n    } else {\n      val = Decoder.nullcheck(state.value)\n      if (s.length > 0) {\n        const nextByte = s.read(1)\n\n        s.unshift(nextByte)\n        throw new UnexpectedDataError(nextByte[0], val)\n      }\n    }\n    return val\n  }\n\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|string} [options={}] Options or encoding\n   *   for input.\n   * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.\n   * @throws {TypeError} No input provided.\n   * @throws {Error} Insufficient data provided.\n   * @static\n   */\n  static decodeAllSync(input, options = {}) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options} = normalizeOptions(options))\n    const {encoding = 'hex', ...opts} = options\n    const c = new Decoder(opts)\n    const s = utils.guessEncoding(input, encoding)\n    const res = []\n\n    while (s.length > 0) {\n      const parser = c._parse()\n      let state = parser.next()\n\n      while (!state.done) {\n        const b = s.read(state.value)\n\n        if ((b == null) || (b.length !== state.value)) {\n          throw new Error('Insufficient data')\n        }\n        if (c.extendedResults) {\n          c.valueBytes.write(b)\n        }\n        state = parser.next(b)\n      }\n      res.push(Decoder.nullcheck(state.value))\n    }\n    return res\n  }\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are\n   * more bytes left over at the end (if options.extendedResults is not true),\n   * and optionally if there were no valid CBOR bytes in the input.  Emits the\n   * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the\n   * `required` option is false.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the\n   *   callback, or input encoding.\n   * @param {decodeCallback} [cb] Callback.\n   * @returns {Promise<ExtendedResults|any>} Returned even if callback is\n   *   specified.\n   * @throws {TypeError} No input provided.\n   * @static\n   */\n  static decodeFirst(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', required = false, ...opts} = options\n\n    const c = new Decoder(opts)\n    let v = /** @type {any} */ (NOT_FOUND)\n    const s = utils.guessEncoding(input, encoding)\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val)\n        c.close()\n      })\n      c.once('error', er => {\n        if (c.extendedResults && (er instanceof UnexpectedDataError)) {\n          v.unused = c.bs.slice()\n          return resolve(v)\n        }\n        if (v !== NOT_FOUND) {\n          // Typescript work-around\n          // eslint-disable-next-line dot-notation\n          er['value'] = v\n        }\n        v = ERROR\n        c.close()\n        return reject(er)\n      })\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'))\n            }\n            return resolve(v)\n          // Pretty sure this can't happen, but not *certain*.\n          /* istanbul ignore next */\n          case ERROR:\n            /* istanbul ignore next */\n            return undefined\n          default:\n            return resolve(v)\n        }\n      })\n    })\n\n    if (typeof cb === 'function') {\n      p.then(val => cb(null, val), cb)\n    }\n    s.pipe(c)\n    return p\n  }\n\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error If one was generated.\n   * @param {Array<ExtendedResults>|Array<any>} value All of the decoded\n   *   values, wrapped in an Array.\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @param {BufferLike} input What to parse?\n   * @param {DecoderOptions|decodeAllCallback|string} [options={}]\n   *   Decoding options, the callback, or the input encoding.\n   * @param {decodeAllCallback} [cb] Callback.\n   * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback\n   *   is specified.\n   * @throws {TypeError} No input specified.\n   * @static\n   */\n  static decodeAll(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const c = new Decoder(opts)\n    const vals = []\n\n    c.on('data', val => vals.push(Decoder.nullcheck(val)))\n\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject)\n      c.on('end', () => resolve(vals))\n    })\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(undefined, v), er => cb(er, undefined))\n    }\n    utils.guessEncoding(input, encoding).pipe(c)\n    return p\n  }\n\n  /**\n   * Stop processing.\n   */\n  close() {\n    this.running = false\n    this.__fresh = true\n  }\n\n  /**\n   * Only called if extendedResults is true.\n   *\n   * @ignore\n   */\n  _onRead(data) {\n    this.valueBytes.write(data)\n  }\n\n  /**\n   * @returns {Generator<number, any, Buffer>} Yields a number of bytes,\n   *   returns anything, next returns a Buffer.\n   * @throws {Error} Maximum depth exceeded.\n   * @yields {number} Number of bytes to read.\n   * @ignore\n   */\n  *_parse() {\n    let parent = null\n    let depth = 0\n    let val = null\n\n    while (true) {\n      if ((this.max_depth >= 0) && (depth > this.max_depth)) {\n        throw new Error(`Maximum depth ${this.max_depth} exceeded`)\n      }\n\n      const [octet] = yield 1\n      if (!this.running) {\n        this.bs.unshift(Buffer.from([octet]))\n        throw new UnexpectedDataError(octet)\n      }\n      const mt = octet >> 5\n      const ai = octet & 0x1f\n      const parent_major = (parent == null) ? undefined : parent[MAJOR]\n      const parent_length = (parent == null) ? undefined : parent.length\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length)\n          ;[val] = yield 1\n          break\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT: {\n          const numbytes = 1 << (ai - 24)\n\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)\n          const buf = yield numbytes\n          val = (mt === MT.SIMPLE_FLOAT) ?\n            buf :\n            utils.parseCBORint(ai, buf)\n          break\n        }\n        case 28:\n        case 29:\n        case 30:\n          this.running = false\n          throw new Error(`Additional info not implemented: ${ai}`)\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(`Invalid indefinite encoding for MT ${mt}`)\n          }\n          val = -1\n          break\n        default:\n          val = ai\n      }\n      switch (mt) {\n        case MT.POS_INT:\n          // Val already decoded\n          break\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BI.NEG_MAX\n          } else {\n            val = (typeof val === 'bigint') ? BI.MINUS_ONE - val : -1 - val\n          }\n          break\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              if (mt === MT.UTF8_STRING) {\n                val = ''\n              } else {\n                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0)\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentBufferStream(parent, mt)\n              depth++\n              continue\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length)\n              val = yield val\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val)\n              } else if (this.preferWeb) {\n                val = new Uint8Array(val.buffer, val.byteOffset, val.length)\n              }\n          }\n          break\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              if (mt === MT.MAP) {\n                val = (this.preferMap) ? new Map() : {}\n              } else {\n                val = []\n              }\n              break\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)\n              parent = parentArray(parent, mt, -1)\n              depth++\n              continue\n            default:\n              this.emit('start', mt, val, parent_major, parent_length)\n              parent = parentArray(parent, mt, val * (mt - 3))\n              depth++\n              continue\n          }\n          break\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length)\n          parent = parentArray(parent, mt, 1)\n          parent.push(val)\n          depth++\n          continue\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if ((ai === NUMBYTES.ONE) && (val < 32)) {\n              throw new Error(\n                `Invalid two-byte encoding of simple value ${val}`\n              )\n            }\n            const hasParent = (parent != null)\n            val = Simple.decode(\n              val,\n              hasParent,\n              hasParent && (parent[COUNT] < 0)\n            )\n          } else {\n            val = utils.parseCBORfloat(val)\n          }\n      }\n      this.emit('value', val, parent_major, parent_length, ai)\n      let again = false\n      while (parent != null) {\n        if (val === SYMS.BREAK) {\n          parent[COUNT] = 1\n        } else if (Array.isArray(parent)) {\n          parent.push(val)\n        } else {\n          // Assert: parent instanceof NoFilter\n          const pm = parent[MAJOR]\n\n          if ((pm != null) && (pm !== mt)) {\n            this.running = false\n            throw new Error('Invalid major type in indefinite encoding')\n          }\n          parent.write(val)\n        }\n\n        if ((--parent[COUNT]) !== 0) {\n          again = true\n          break\n        }\n        --depth\n        delete parent[COUNT]\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent\n              break\n            case MT.MAP: {\n              let allstrings = !this.preferMap\n\n              if ((parent.length % 2) !== 0) {\n                throw new Error(`Invalid map length: ${parent.length}`)\n              }\n              for (\n                let i = 0, len = parent.length;\n                allstrings && (i < len);\n                i += 2\n              ) {\n                if ((typeof parent[i] !== 'string') ||\n                    (parent[i] === '__proto__')) {\n                  allstrings = false\n                  break\n                }\n              }\n              if (allstrings) {\n                val = {}\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys &&\n                    Object.prototype.hasOwnProperty.call(val, parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val[parent[i]] = parent[i + 1]\n                }\n              } else {\n                val = new Map()\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  if (this.preventDuplicateKeys && val.has(parent[i])) {\n                    throw new Error('Duplicate keys in a map')\n                  }\n                  val.set(parent[i], parent[i + 1])\n                }\n              }\n              break\n            }\n            case MT.TAG: {\n              const t = new Tagged(parent[0], parent[1])\n\n              val = t.convert(this.tags)\n              break\n            }\n          }\n        } else /* istanbul ignore else */ if (parent instanceof NoFilter) {\n          // Only parent types are Array and NoFilter for (Array/Map) and\n          // (bytes/string) respectively.\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice()\n              if (this.preferWeb) {\n                val = new Uint8Array(\n                  /** @type {Buffer} */ (val).buffer,\n                  /** @type {Buffer} */ (val).byteOffset,\n                  /** @type {Buffer} */ (val).length\n                )\n              }\n              break\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8')\n              break\n          }\n        }\n        this.emit('stop', parent[MAJOR])\n\n        const old = parent\n        parent = parent[SYMS.PARENT]\n        delete old[SYMS.PARENT]\n        delete old[MAJOR]\n      }\n      if (!again) {\n        if (this.extendedResults) {\n          const bytes = this.valueBytes.slice()\n          const ret = {\n            value: Decoder.nullcheck(val),\n            bytes,\n            length: bytes.length,\n          }\n\n          this.valueBytes = new NoFilter()\n          return ret\n        }\n        return val\n      }\n    }\n  }\n}\n\nDecoder.NOT_FOUND = NOT_FOUND\nmodule.exports = Decoder\n","'use strict'\n\nconst stream = require('stream')\nconst Decoder = require('./decoder')\nconst utils = require('./utils')\nconst NoFilter = require('nofilter')\nconst {MT, SYMS} = require('./constants')\n\n/**\n * Things that can act as inputs, from which a NoFilter can be created.\n *\n * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray\n *   |DataView|stream.Readable} BufferLike\n */\n\n/**\n * @typedef DiagnoseOptions\n * @property {string} [separator='\\n'] Output between detected objects.\n * @property {boolean} [stream_errors=false] Put error info into the\n *   output stream.\n * @property {number} [max_depth=-1] The maximum depth to parse.\n *   Use -1 for \"until you run out of memory\".  Set this to a finite\n *   positive number for un-trusted inputs.  Most standard inputs won't nest\n *   more than 100 or so levels; I've tested into the millions before\n *   running out of memory.\n * @property {object} [tags] Mapping from tag number to function(v),\n *   where v is the decoded value that comes after the tag, and where the\n *   function returns the correctly-created value for that tag.\n * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to\n *   be generated instead of node Buffers.  This might turn on some more\n *   changes in the future, so forward-compatibility is not guaranteed yet.\n * @property {BufferEncoding} [encoding='hex'] The encoding of input, ignored if\n *   input is not string.\n */\n/**\n * @callback diagnoseCallback\n * @param {Error} [error] If one was generated.\n * @param {string} [value] The diagnostic value.\n * @returns {void}\n */\n/**\n * @param {DiagnoseOptions|diagnoseCallback|string} opts Options,\n *   the callback, or input incoding.\n * @param {diagnoseCallback} [cb] Called on completion.\n * @returns {{options: DiagnoseOptions, cb: diagnoseCallback}} Normalized.\n * @throws {TypeError} Unknown option type.\n * @private\n */\nfunction normalizeOptions(opts, cb) {\n  switch (typeof opts) {\n    case 'function':\n      return {options: {}, cb: /** @type {diagnoseCallback} */ (opts)}\n    case 'string':\n      return {options: {encoding: /** @type {BufferEncoding} */ (opts)}, cb}\n    case 'object':\n      return {options: opts || {}, cb}\n    default:\n      throw new TypeError('Unknown option type')\n  }\n}\n\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends stream.Transform\n */\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {DiagnoseOptions} [options={}] Options for creation.\n   */\n  constructor(options = {}) {\n    const {\n      separator = '\\n',\n      stream_errors = false,\n      // Decoder options\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n      // Stream.Transform options\n      ...superOpts\n    } = options\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: false,\n    })\n\n    this.float_bytes = -1\n    this.separator = separator\n    this.stream_errors = stream_errors\n    this.parser = new Decoder({\n      tags,\n      max_depth,\n      preferWeb,\n      encoding,\n    })\n    this.parser.on('more-bytes', this._on_more.bind(this))\n    this.parser.on('value', this._on_value.bind(this))\n    this.parser.on('start', this._on_start.bind(this))\n    this.parser.on('stop', this._on_stop.bind(this))\n    this.parser.on('data', this._on_data.bind(this))\n    this.parser.on('error', this._on_error.bind(this))\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.parser.write(fresh, encoding, cb)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er)\n        }\n        return cb()\n      }\n      return cb(er)\n    })\n  }\n\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {BufferLike} input The CBOR bytes to format.\n   * @param {DiagnoseOptions |diagnoseCallback|string} [options={}]\n   *   Options, the callback, or the input encoding.\n   * @param {diagnoseCallback} [cb] Callback.\n   * @returns {Promise} If callback not specified.\n   * @throws {TypeError} Input not provided.\n   */\n  static diagnose(input, options = {}, cb = null) {\n    if (input == null) {\n      throw new TypeError('input required')\n    }\n    ({options, cb} = normalizeOptions(options, cb))\n    const {encoding = 'hex', ...opts} = options\n\n    const bs = new NoFilter()\n    const d = new Diagnose(opts)\n    let p = null\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')))\n      d.on('error', cb)\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')))\n        d.on('error', reject)\n      })\n    }\n    d.pipe(bs)\n    utils.guessEncoding(input, encoding).pipe(d)\n    return p\n  }\n\n  /**\n   * @ignore\n   */\n  _on_error(er) {\n    if (this.stream_errors) {\n      this.push(er.toString())\n    } else {\n      this.emit('error', er)\n    }\n  }\n\n  /** @private */\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3,\n      }[len]\n    }\n  }\n\n  /** @private */\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          this.push(', ')\n        }\n        break\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            this.push(': ')\n          } else {\n            this.push(', ')\n          }\n        }\n    }\n  }\n\n  /** @private */\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return\n    }\n    this._fore(parent_mt, pos)\n    const fb = this.float_bytes\n    this.float_bytes = -1\n    this.push(utils.cborValueToString(val, fb))\n  }\n\n  /** @private */\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos)\n    switch (mt) {\n      case MT.TAG:\n        this.push(`${tag}(`)\n        break\n      case MT.ARRAY:\n        this.push('[')\n        break\n      case MT.MAP:\n        this.push('{')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(')\n        break\n    }\n    if (tag === SYMS.STREAM) {\n      this.push('_ ')\n    }\n  }\n\n  /** @private */\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        this.push(')')\n        break\n      case MT.ARRAY:\n        this.push(']')\n        break\n      case MT.MAP:\n        this.push('}')\n        break\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push(')')\n        break\n    }\n  }\n\n  /** @private */\n  _on_data() {\n    this.push(this.separator)\n  }\n}\n\nmodule.exports = Diagnose\n","'use strict'\n\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\nconst utils = require('./utils')\nconst constants = require('./constants')\nconst {\n  MT, NUMBYTES, SHIFT32, SIMPLE, SYMS, TAG, BI,\n} = constants\nconst {Buffer} = require('buffer')\n\nconst HALF = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.TWO\nconst FLOAT = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.FOUR\nconst DOUBLE = (MT.SIMPLE_FLOAT << 5) | NUMBYTES.EIGHT\nconst TRUE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.TRUE\nconst FALSE = (MT.SIMPLE_FLOAT << 5) | SIMPLE.FALSE\nconst UNDEFINED = (MT.SIMPLE_FLOAT << 5) | SIMPLE.UNDEFINED\nconst NULL = (MT.SIMPLE_FLOAT << 5) | SIMPLE.NULL\n\nconst BREAK = Buffer.from([0xff])\nconst BUF_NAN = Buffer.from('f97e00', 'hex')\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex')\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex')\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex')\n\n/**\n * Generate the CBOR for a value.  If you are using this, you'll either need\n * to call {@link Encoder.write} with a Buffer, or look into the internals of\n * Encoder to reuse existing non-documented behavior.\n *\n * @callback EncodeFunction\n * @param {Encoder} enc The encoder to use.\n * @param {any} val The value to encode.\n * @returns {boolean} True on success.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, EncodeFunction>} SemanticMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {SemanticMap}\n * @private\n */\nconst SEMANTIC_TYPES = {}\n\n/**\n * @type {SemanticMap}\n * @private\n */\nlet current_SEMANTIC_TYPES = {}\n\n/**\n * @param {string} str String to normalize.\n * @returns {\"number\"|\"float\"|\"int\"|\"string\"} Normalized.\n * @throws {TypeError} Invalid input.\n * @private\n */\nfunction parseDateType(str) {\n  if (!str) {\n    return 'number'\n  }\n  switch (str.toLowerCase()) {\n    case 'number':\n      return 'number'\n    case 'float':\n      return 'float'\n    case 'int':\n    case 'integer':\n      return 'int'\n    case 'string':\n      return 'string'\n  }\n  throw new TypeError(`dateType invalid, got \"${str}\"`)\n}\n\n/**\n * @typedef ObjectOptions\n * @property {boolean} [indefinite = false] Force indefinite encoding for this\n *   object.\n * @property {boolean} [skipTypes = false] Do not use available type mappings\n *   for this object, but encode it as a \"normal\" JS object would be.\n */\n\n/**\n * @typedef EncodingOptions\n * @property {any[]|object} [genTypes=[]] Array of pairs of\n *   `type`, `function(Encoder)` for semantic types to be encoded.  Not\n *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.\n *   If an object, the keys are the constructor names for the types.\n * @property {boolean} [canonical=false] Should the output be\n *   canonicalized.\n * @property {boolean|WeakSet} [detectLoops=false] Should object loops\n *   be detected?  This will currently add memory to track every part of the\n *   object being encoded in a WeakSet.  Do not encode\n *   the same object twice on the same encoder, without calling\n *   `removeLoopDetectors` in between, which will clear the WeakSet.\n *   You may pass in your own WeakSet to be used; this is useful in some\n *   recursive scenarios.\n * @property {(\"number\"|\"float\"|\"int\"|\"string\")} [dateType=\"number\"] -\n *   how should dates be encoded?  \"number\" means float or int, if no\n *   fractional seconds.\n * @property {any} [encodeUndefined=undefined] How should an\n *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n *   undefined.  If this is a buffer, use those bytes without re-encoding\n *   them.  If this is a function, the function will be called (which is a\n *   good time to throw an exception, if that's what you want), and the\n *   return value will be used according to these rules.  Anything else will\n *   be encoded as CBOR.\n * @property {boolean} [disallowUndefinedKeys=false] Should\n *   \"undefined\" be disallowed as a key in a Map that is serialized?  If\n *   this is true, encode(new Map([[undefined, 1]])) will throw an\n *   exception.  Note that it is impossible to get a key of undefined in a\n *   normal JS object.\n * @property {boolean} [collapseBigIntegers=false] Should integers\n *   that come in as ECMAscript bigint's be encoded\n *   as normal CBOR integers if they fit, discarding type information?\n * @property {number} [chunkSize=4096] Number of characters or bytes\n *   for each chunk, if obj is a string or Buffer, when indefinite encoding.\n * @property {boolean} [omitUndefinedProperties=false] When encoding\n *   objects or Maps, do not include a key if its corresponding value is\n *   `undefined`.\n */\n\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends stream.Transform\n */\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {EncodingOptions} [options={}] Options for the encoder.\n   */\n  constructor(options = {}) {\n    const {\n      canonical = false,\n      encodeUndefined,\n      disallowUndefinedKeys = false,\n      dateType = 'number',\n      collapseBigIntegers = false,\n      detectLoops = false,\n      omitUndefinedProperties = false,\n      genTypes = [],\n      ...superOpts\n    } = options\n\n    super({\n      ...superOpts,\n      readableObjectMode: false,\n      writableObjectMode: true,\n    })\n\n    this.canonical = canonical\n    this.encodeUndefined = encodeUndefined\n    this.disallowUndefinedKeys = disallowUndefinedKeys\n    this.dateType = parseDateType(dateType)\n    this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers\n\n    /** @type {WeakSet?} */\n    this.detectLoops = undefined\n    if (typeof detectLoops === 'boolean') {\n      if (detectLoops) {\n        this.detectLoops = new WeakSet()\n      }\n    } else if (detectLoops instanceof WeakSet) {\n      this.detectLoops = detectLoops\n    } else {\n      throw new TypeError('detectLoops must be boolean or WeakSet')\n    }\n    this.omitUndefinedProperties = omitUndefinedProperties\n\n    this.semanticTypes = {...Encoder.SEMANTIC_TYPES}\n\n    if (Array.isArray(genTypes)) {\n      for (let i = 0, len = genTypes.length; i < len; i += 2) {\n        this.addSemanticType(genTypes[i], genTypes[i + 1])\n      }\n    } else {\n      for (const [k, v] of Object.entries(genTypes)) {\n        this.addSemanticType(k, v)\n      }\n    }\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh)\n    // Old transformers might not return bool.  undefined !== false\n    cb((ret === false) ? new Error('Push Error') : undefined)\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _flush(cb) {\n    cb()\n  }\n\n  /**\n   * @param {number} val Number(0-255) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1)\n    b.writeUInt8(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0-65535) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2)\n    b.writeUInt16BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number(0..2**32-1) to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeUInt32BE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 4-byte float.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4)\n    b.writeFloatBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @param {number} val Number to encode as 8-byte double.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8)\n    b.writeDoubleBE(val, 0)\n    return this.push(b)\n  }\n\n  /**\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNaN() {\n    return this.push(BUF_NAN)\n  }\n\n  /**\n   * @param {number} obj Positive or negative infinity.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInfinity(obj) {\n    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS\n    return this.push(half)\n  }\n\n  /**\n   * Choose the best float representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be not-integer, but not\n   *   how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2)\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2)\n      }\n    }\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a postive number and encode\n   * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I\n   * don't remember why).\n   *\n   * @param {number} obj A positive number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @param {number} mt The Major Type number to combine with the integer.\n   *   Not yet shifted.\n   * @param {number} [orig] The number before it was transformed to positive.\n   *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,\n   *   then we'll encode this as a float rather than making the number\n   *   negative again and losing precision.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5\n\n    if (obj < 24) {\n      return this._pushUInt8(m | obj)\n    }\n    if (obj <= 0xff) {\n      return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)\n    }\n    if (obj <= 0xffff) {\n      return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)\n    }\n    if (obj <= 0xffffffff) {\n      return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)\n    }\n    let max = Number.MAX_SAFE_INTEGER\n    if (mt === MT.NEG_INT) {\n      // Special case for Number.MIN_SAFE_INTEGER - 1\n      max--\n    }\n    if (obj <= max) {\n      return this._pushUInt8(m | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&\n        this._pushUInt32BE(obj % SHIFT32)\n    }\n    if (mt === MT.NEG_INT) {\n      return this._pushFloat(orig)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * Choose the best integer representation for a number and encode it.\n   *\n   * @param {number} obj A number that is known to be an integer,\n   *   but not how many bytes of precision it needs.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO)\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj)\n    }\n    return this._pushInt(obj, MT.POS_INT)\n  }\n\n  /**\n   * @param {number} obj Plain JS number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNumber(obj) {\n    if (isNaN(obj)) {\n      return this._pushNaN()\n    }\n    if (!isFinite(obj)) {\n      return this._pushInfinity(obj)\n    }\n    if (Math.round(obj) === obj) {\n      return this._pushIntNum(obj)\n    }\n    return this._pushFloat(obj)\n  }\n\n  /**\n   * @param {string} obj String to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8')\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')\n  }\n\n  /**\n   * @param {boolean} obj Bool to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE)\n  }\n\n  /**\n   * @param {undefined} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED)\n      case 'function':\n        return this.pushAny(this.encodeUndefined(obj))\n      case 'object': {\n        const buf = utils.bufferishToBuffer(this.encodeUndefined)\n        if (buf) {\n          return this.push(buf)\n        }\n      }\n    }\n    return this.pushAny(this.encodeUndefined)\n  }\n\n  /**\n   * @param {null} obj Ignored.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushNull(obj) {\n    return this._pushUInt8(NULL)\n  }\n\n  /**\n   * @param {number} tag Tag number to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG)\n  }\n\n  /**\n   * @param {bigint} obj BigInt to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT\n    let tag = TAG.POS_BIGINT\n    // BigInt doesn't have -0\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE\n      m = MT.NEG_INT\n      tag = TAG.NEG_BIGINT\n    }\n\n    if (this.collapseBigIntegers &&\n        (obj <= BI.MAXINT64)) {\n      // Special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m)\n      }\n      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&\n        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&\n        this._pushUInt32BE(Number(obj % BI.SHIFT32))\n    }\n\n    let str = obj.toString(16)\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    const buf = Buffer.from(str, 'hex')\n    return this._pushTag(tag) && Encoder._pushBuffer(this, buf)\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {ObjectOptions} [opts] Options for encoding this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj)\n    }\n    opts = {\n      indefinite: false,\n      skipTypes: false,\n      ...opts,\n    }\n    if (!opts.indefinite) {\n      // This will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (this.detectLoops.has(obj)) {\n          throw new Error(`\\\nLoop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.`)\n        } else {\n          this.detectLoops.add(obj)\n        }\n      }\n    }\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR\n      if (typeof f === 'function') {\n        return f.call(obj, this)\n      }\n      const converter = this.semanticTypes[obj.constructor.name]\n      if (converter) {\n        return converter.call(obj, this, obj)\n      }\n    }\n    const keys = Object.keys(obj).filter(k => {\n      const tv = typeof obj[k]\n      return (tv !== 'function') &&\n        (!this.omitUndefinedProperties || (tv !== 'undefined'))\n    })\n    const cbor_keys = {}\n    if (this.canonical) {\n      // Note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))\n\n        return a_cbor.compare(b_cbor)\n      })\n    }\n    if (opts.indefinite) {\n      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false\n    }\n    let ck = null\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j]\n      if (this.canonical && ((ck = cbor_keys[k]))) {\n        if (!this.push(ck)) { // Already a Buffer\n          return false\n        }\n      } else if (!this._pushString(k)) {\n        return false\n      }\n      if (!this.pushAny(obj[k])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false\n      }\n    } else if (this.detectLoops) {\n      this.detectLoops.delete(obj)\n    }\n    return true\n  }\n\n  /**\n   * @param {any[]} objs Array of supported things.\n   * @returns {Buffer} Concatenation of encodings for the supported things.\n   * @ignore\n   */\n  _encodeAll(objs) {\n    const bs = new NoFilter({highWaterMark: this.readableHighWaterMark})\n    this.pipe(bs)\n    for (const o of objs) {\n      this.pushAny(o)\n    }\n    this.end()\n    return bs.read()\n  }\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This\n   * is useful for objects for which you can't add an encodeCBOR method.\n   *\n   * @param {string|Function} type The type to encode.\n   * @param {EncodeFunction} fun The encoder to use.\n   * @returns {EncodeFunction?} The previous encoder or undefined if there\n   *   wasn't one.\n   * @throws {TypeError} Invalid function.\n   */\n  addSemanticType(type, fun) {\n    const typeName = (typeof type === 'string') ? type : type.name\n    const old = this.semanticTypes[typeName]\n\n    if (fun) {\n      if (typeof fun !== 'function') {\n        throw new TypeError('fun must be of type function')\n      }\n      this.semanticTypes[typeName] = fun\n    } else if (old) {\n      delete this.semanticTypes[typeName]\n    }\n    return old\n  }\n\n  /**\n   * Push any supported type onto the encoded stream.\n   *\n   * @param {any} obj The thing to encode.\n   * @returns {boolean} True on success.\n   * @throws {TypeError} Unknown type for obj.\n   */\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj)\n      case 'bigint':\n        return this._pushJSBigint(obj)\n      case 'string':\n        return this._pushString(obj)\n      case 'boolean':\n        return this._pushBoolean(obj)\n      case 'undefined':\n        return this._pushUndefined(obj)\n      case 'object':\n        return this._pushObject(obj)\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null)\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(undefined)\n          // TODO: Add pluggable support for other symbols\n          default:\n            throw new TypeError(`Unknown symbol: ${obj.toString()}`)\n        }\n      default:\n        throw new TypeError(\n          `Unknown type: ${typeof obj}, ${(typeof obj.toString === 'function') ? obj.toString() : ''}`\n        )\n    }\n  }\n\n  /**\n   * Encode an array and all of its elements.\n   *\n   * @param {Encoder} gen Encoder to use.\n   * @param {any[]} obj Array to encode.\n   * @param {object} [opts] Options.\n   * @param {boolean} [opts.indefinite=false] Use indefinite encoding?\n   * @returns {boolean} True on success.\n   */\n  static pushArray(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    const len = obj.length\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false\n    }\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * Remove the loop detector WeakSet for this Encoder.\n   *\n   * @returns {boolean} True when the Encoder was reset, else false.\n   */\n  removeLoopDetectors() {\n    if (!this.detectLoops) {\n      return false\n    }\n    this.detectLoops = new WeakSet()\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Date} obj Date to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) &&\n          gen._pushString(obj.toISOString())\n      case 'int':\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushIntNum(Math.round(obj.getTime() / 1000))\n      case 'float':\n        // Force float\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen._pushFloat(obj.getTime() / 1000)\n      case 'number':\n      default:\n        // If we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) &&\n          gen.pushAny(obj.getTime() / 1000)\n    }\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Buffer} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NoFilter} obj Buffer to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushNoFilter(gen, obj) {\n    return Encoder._pushBuffer(gen, /** @type {Buffer} */ (obj.slice()))\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {RegExp} obj RegExp to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Set} obj Set to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushSet(gen, obj) {\n    if (!gen._pushTag(TAG.SET)) {\n      return false\n    }\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false\n    }\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {URL} obj URL to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {object} obj Boxed String, Number, or Boolean object to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushBoxed(gen, obj) {\n    return gen.pushAny(obj.valueOf())\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {Map} obj Map to encode.\n   * @returns {boolean} True on success.\n   * @throws {Error} Map key that is undefined.\n   * @ignore\n   */\n  static _pushMap(gen, obj, opts) {\n    opts = {\n      indefinite: false,\n      ...opts,\n    }\n    let entries = [...obj.entries()]\n    if (gen.omitUndefinedProperties) {\n      entries = entries.filter(([k, v]) => v !== undefined)\n    }\n    if (opts.indefinite) {\n      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {\n        return false\n      }\n    } else if (!gen._pushInt(entries.length, MT.MAP)) {\n      return false\n    }\n    // Memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n    if (gen.canonical) {\n      // Keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const enc = new Encoder({\n        genTypes: gen.semanticTypes,\n        canonical: gen.canonical,\n        detectLoops: Boolean(gen.detectLoops), // Give enc its own loop detector\n        dateType: gen.dateType,\n        disallowUndefinedKeys: gen.disallowUndefinedKeys,\n        collapseBigIntegers: gen.collapseBigIntegers,\n      })\n      const bs = new NoFilter({highWaterMark: gen.readableHighWaterMark})\n      enc.pipe(bs)\n      entries.sort(([a], [b]) => {\n        // Both a and b are the keys\n        enc.pushAny(a)\n        const a_cbor = bs.read()\n        enc.pushAny(b)\n        const b_cbor = bs.read()\n        return a_cbor.compare(b_cbor)\n      })\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    } else {\n      for (const [k, v] of entries) {\n        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {\n          throw new Error('Invalid Map key: undefined')\n        }\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false\n        }\n      }\n    }\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param {NodeJS.TypedArray} obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushTypedArray(gen, obj) {\n    // See https://tools.ietf.org/html/rfc8746\n\n    let typ = 0b01000000\n    let sz = obj.BYTES_PER_ELEMENT\n    const {name} = obj.constructor\n\n    if (name.startsWith('Float')) {\n      typ |= 0b00010000\n      sz /= 2\n    } else if (!name.includes('U')) {\n      typ |= 0b00001000\n    }\n    if (name.includes('Clamped') || ((sz !== 1) && !utils.isBigEndian())) {\n      typ |= 0b00000100\n    }\n    typ |= {\n      1: 0b00,\n      2: 0b01,\n      4: 0b10,\n      8: 0b11,\n    }[sz]\n    if (!gen._pushTag(typ)) {\n      return false\n    }\n    return Encoder._pushBuffer(\n      gen,\n      Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength)\n    )\n  }\n\n  /**\n   * @param {Encoder} gen Encoder.\n   * @param { ArrayBuffer } obj Array to encode.\n   * @returns {boolean} True on success.\n   * @ignore\n   */\n  static _pushArrayBuffer(gen, obj) {\n    return Encoder._pushBuffer(gen, Buffer.from(obj))\n  }\n\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  See the example for how to add this as an\n   * `encodeCBOR` function to an object or class to get indefinite encoding.\n   *\n   * @param {Encoder} gen The encoder to use.\n   * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {EncodingOptions} [options={}] Options for encoding.\n   * @returns {boolean} True on success.\n   * @throws {Error} No object to encode or invalid indefinite encoding.\n   * @example <caption>Force indefinite encoding:</caption>\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite,\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   */\n  static encodeIndefinite(gen, obj, options = {}) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode')\n      }\n      obj = this\n    }\n\n    // TODO: consider other options\n    const {chunkSize = 4096} = options\n\n    let ret = true\n    const objType = typeof obj\n    let buf = null\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < obj.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && gen._pushString(obj.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if ((buf = utils.bufferishToBuffer(obj))) {\n      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)\n      let offset = 0\n      while (offset < buf.length) {\n        const endIndex = offset + chunkSize\n        ret = ret && Encoder._pushBuffer(gen, buf.slice(offset, endIndex))\n        offset = endIndex\n      }\n      ret = ret && gen.push(BREAK)\n    } else if (Array.isArray(obj)) {\n      ret = ret && Encoder.pushArray(gen, obj, {\n        indefinite: true,\n      })\n    } else if (obj instanceof Map) {\n      ret = ret && Encoder._pushMap(gen, obj, {\n        indefinite: true,\n      })\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding')\n      }\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true,\n      })\n    }\n    return ret\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs)\n  }\n\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true,\n    })._encodeAll(objs)\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = []\n      const enc = new Encoder(options)\n      enc.on('data', buf => bufs.push(buf))\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n\n  /**\n   * The currently supported set of semantic types.  May be modified by plugins.\n   *\n   * @type {SemanticMap}\n   */\n  static get SEMANTIC_TYPES() {\n    return current_SEMANTIC_TYPES\n  }\n\n  static set SEMANTIC_TYPES(val) {\n    current_SEMANTIC_TYPES = val\n  }\n\n  /**\n   * Reset the supported semantic types to the original set, before any\n   * plugins modified the list.\n   */\n  static reset() {\n    Encoder.SEMANTIC_TYPES = {...SEMANTIC_TYPES}\n  }\n}\n\nObject.assign(SEMANTIC_TYPES, {\n  Array: Encoder.pushArray,\n  Date: Encoder._pushDate,\n  Buffer: Encoder._pushBuffer,\n  [Buffer.name]: Encoder._pushBuffer, // Might be mangled\n  Map: Encoder._pushMap,\n  NoFilter: Encoder._pushNoFilter,\n  [NoFilter.name]: Encoder._pushNoFilter, // Might be mangled\n  RegExp: Encoder._pushRegexp,\n  Set: Encoder._pushSet,\n  ArrayBuffer: Encoder._pushArrayBuffer,\n  Uint8ClampedArray: Encoder._pushTypedArray,\n  Uint8Array: Encoder._pushTypedArray,\n  Uint16Array: Encoder._pushTypedArray,\n  Uint32Array: Encoder._pushTypedArray,\n  Int8Array: Encoder._pushTypedArray,\n  Int16Array: Encoder._pushTypedArray,\n  Int32Array: Encoder._pushTypedArray,\n  Float32Array: Encoder._pushTypedArray,\n  Float64Array: Encoder._pushTypedArray,\n  URL: Encoder._pushURL,\n  Boolean: Encoder._pushBoxed,\n  Number: Encoder._pushBoxed,\n  String: Encoder._pushBoxed,\n})\n\n// Safari needs to get better.\nif (typeof BigUint64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray\n}\nif (typeof BigInt64Array !== 'undefined') {\n  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray\n}\n\nEncoder.reset()\nmodule.exports = Encoder\n","'use strict'\n\nconst {Buffer} = require('buffer')\nconst encoder = require('./encoder')\nconst decoder = require('./decoder')\nconst {MT} = require('./constants')\n\n/**\n * Wrapper around a JavaScript Map object that allows the keys to be\n * any complex type.  The base Map object allows this, but will only\n * compare the keys by identity, not by value.  CborMap translates keys\n * to CBOR first (and base64's them to ensure by-value comparison).\n *\n * This is not a subclass of Object, because it would be tough to get\n * the semantics to be an exact match.\n *\n * @extends Map\n */\nclass CborMap extends Map {\n  /**\n   * Creates an instance of CborMap.\n   *\n   * @param {Iterable<any>} [iterable] An Array or other iterable\n   *   object whose elements are key-value pairs (arrays with two elements, e.g.\n   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added\n   *   to the new CborMap; null values are treated as undefined.\n   */\n  constructor(iterable) {\n    super(iterable)\n  }\n\n  /**\n   * @ignore\n   */\n  static _encode(key) {\n    return encoder.encodeCanonical(key).toString('base64')\n  }\n\n  /**\n   * @ignore\n   */\n  static _decode(key) {\n    return decoder.decodeFirstSync(key, 'base64')\n  }\n\n  /**\n   * Retrieve a specified element.\n   *\n   * @param {any} key The key identifying the element to retrieve.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {any} The element if it exists, or <code>undefined</code>.\n   */\n  get(key) {\n    return super.get(CborMap._encode(key))\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {any} key The key identifying the element to store.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @param {any} val The element to store.\n   * @returns {this} This object.\n   */\n  set(key, val) {\n    return super.set(CborMap._encode(key), val)\n  }\n\n  /**\n   * Removes the specified element.\n   *\n   * @param {any} key The key identifying the element to delete. Can be any\n   *   type, which will be serialized into CBOR and compared by value.\n   * @returns {boolean} True if an element in the Map object existed and has\n   *   been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    return super.delete(CborMap._encode(key))\n  }\n\n  /**\n   * Does an element with the specified key exist?\n   *\n   * @param {any} key The key identifying the element to check.\n   *   Can be any type, which will be serialized into CBOR and compared by\n   *   value.\n   * @returns {boolean} True if an element with the specified key exists in\n   *   the Map object; otherwise false.\n   */\n  has(key) {\n    return super.has(CborMap._encode(key))\n  }\n\n  /**\n   * Returns a new Iterator object that contains the keys for each element\n   * in the Map object in insertion order.  The keys are decoded into their\n   * original format.\n   *\n   * @yields {any} The keys of the map.\n   */\n  *keys() {\n    for (const k of super.keys()) {\n      yield CborMap._decode(k)\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator<any>} Key value pairs.\n   * @yields {any[]} Key value pairs.\n   */\n  *entries() {\n    for (const kv of super.entries()) {\n      yield [CborMap._decode(kv[0]), kv[1]]\n    }\n  }\n\n  /**\n   * Returns a new Iterator object that contains the [key, value] pairs for\n   * each element in the Map object in insertion order.\n   *\n   * @returns {IterableIterator} Key value pairs.\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * Executes a provided function once per each key/value pair in the Map\n   * object, in insertion order.\n   *\n   * @param {function(any, any, Map): undefined} fun Function to execute for\n   *   each element, which takes a value, a key, and the Map being traversed.\n   * @param {any} thisArg Value to use as this when executing callback.\n   * @throws {TypeError} Invalid function.\n   */\n  forEach(fun, thisArg) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('Must be function')\n    }\n    for (const kv of super.entries()) {\n      fun.call(this, kv[1], CborMap._decode(kv[0]), this)\n    }\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    if (!gen._pushInt(this.size, MT.MAP)) {\n      return false\n    }\n    if (gen.canonical) {\n      const entries = Array.from(super.entries())\n        .map(kv => [Buffer.from(kv[0], 'base64'), kv[1]])\n      entries.sort((a, b) => a[0].compare(b[0]))\n      for (const kv of entries) {\n        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    } else {\n      for (const kv of super.entries()) {\n        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nmodule.exports = CborMap\n","'use strict'\n\n/**\n * Record objects that pass by in a stream.  If the same object is used more\n * than once, it can be value-shared using shared values.\n *\n * @see {@link http://cbor.schmorp.de/value-sharing}\n */\nclass ObjectRecorder {\n  constructor() {\n    this.clear()\n  }\n\n  /**\n   * Clear all of the objects that have been seen.  Revert to recording mode.\n   */\n  clear() {\n    this.map = new WeakMap()\n    this.count = 0\n    this.recording = true\n  }\n\n  /**\n   * Stop recording.\n   */\n  stop() {\n    this.recording = false\n  }\n\n  /**\n   * Determine if wrapping a tag 28 or 29 around an object that has been\n   * reused is appropriate.  This method stores state for which objects have\n   * been seen.\n   *\n   * @param {object} obj Any object about to be serialized.\n   * @returns {number} If recording: -1 for first use, index for second use.\n   *   If not recording, -1 for never-duplicated, -2 for first use, index for\n   *   subsequent uses.\n   * @throws {Error} Recording does not match playback.\n   */\n  check(obj) {\n    const val = this.map.get(obj)\n    if (val) {\n      if (val.length > 1) {\n        if (val[0] || this.recording) {\n          return val[1]\n        }\n\n        val[0] = true\n        return ObjectRecorder.FIRST\n      }\n      if (!this.recording) {\n        return ObjectRecorder.NEVER\n      }\n      val.push(this.count++)\n      // Second use while recording\n      return val[1]\n    }\n    if (!this.recording) {\n      throw new Error('New object detected when not recording')\n    }\n    this.map.set(obj, [false])\n    // First use while recording\n    return ObjectRecorder.NEVER\n  }\n}\n\nObjectRecorder.NEVER = -1\nObjectRecorder.FIRST = -2\n\nmodule.exports = ObjectRecorder\n","'use strict'\n\nconst Encoder = require('./encoder')\nconst ObjectRecorder = require('./objectRecorder')\nconst {Buffer} = require('buffer')\n\n/**\n * Implement value sharing.\n *\n * @see {@link cbor.schmorp.de/value-sharing}\n */\nclass SharedValueEncoder extends Encoder {\n  constructor(opts) {\n    super(opts)\n    this.valueSharing = new ObjectRecorder()\n  }\n\n  /**\n   * @param {object} obj Object to encode.\n   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding\n   *   this object.\n   * @returns {boolean} True on success.\n   * @throws {Error} Loop detected.\n   * @ignore\n   */\n  _pushObject(obj, opts) {\n    if (obj !== null) {\n      const shared = this.valueSharing.check(obj)\n      switch (shared) {\n        case ObjectRecorder.FIRST:\n          // Prefix with tag 28\n          this._pushTag(28)\n          break\n        case ObjectRecorder.NEVER:\n          // Do nothing\n          break\n        default:\n          return this._pushTag(29) && this._pushIntNum(shared)\n      }\n    }\n    return super._pushObject(obj, opts)\n  }\n\n  /**\n   * Between encoding runs, stop recording, and start outputing correct tags.\n   */\n  stopRecording() {\n    this.valueSharing.stop()\n  }\n\n  /**\n   * Remove the existing recording and start over.  Do this between encoding\n   * pairs.\n   */\n  clearRecording() {\n    this.valueSharing.clear()\n  }\n\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} The encoded objects.\n   */\n  static encode(...objs) {\n    const enc = new SharedValueEncoder()\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n\n    for (const o of objs) {\n      enc.pushAny(o)\n    }\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll(objs)\n  }\n\n  // eslint-disable-next-line jsdoc/require-returns-check\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs The objects to encode.\n   * @returns {Buffer} Never.\n   * @throws {Error} Always.  This combination doesn't work at the moment.\n   */\n  static encodeCanonical(...objs) {\n    throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.')\n  }\n\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Buffer} The encoded objects.\n   * @static\n   */\n  static encodeOne(obj, options) {\n    const enc = new SharedValueEncoder(options)\n    // eslint-disable-next-line no-empty-function\n    enc.on('data', () => {}) // Sink all writes\n    enc.pushAny(obj)\n    enc.stopRecording()\n    enc.removeAllListeners('data')\n    return enc._encodeAll([obj])\n  }\n\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this\n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj The object to encode.\n   * @param {import('./encoder').EncodingOptions} [options={}]\n   *   Passed to the Encoder constructor.\n   * @returns {Promise<Buffer>} A promise for the encoded buffer.\n   */\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      /** @type {Buffer[]} */\n      const bufs = []\n      const enc = new SharedValueEncoder(options)\n      // eslint-disable-next-line no-empty-function\n      enc.on('data', () => {})\n      enc.on('error', reject)\n      enc.on('finish', () => resolve(Buffer.concat(bufs)))\n      enc.pushAny(obj)\n      enc.stopRecording()\n      enc.removeAllListeners('data')\n      enc.on('data', buf => bufs.push(buf))\n      enc.pushAny(obj)\n      enc.end()\n    })\n  }\n}\n\nmodule.exports = SharedValueEncoder\n","'use strict'\n\nconst {MT, SIMPLE, SYMS} = require('./constants')\n\n/**\n * A CBOR Simple Value that does not map onto a known constant.\n */\nclass Simple {\n  /**\n   * Creates an instance of Simple.\n   *\n   * @param {number} value The simple value's integer value.\n   */\n  constructor(value) {\n    if (typeof value !== 'number') {\n      throw new Error(`Invalid Simple type: ${typeof value}`)\n    }\n    if ((value < 0) || (value > 255) || ((value | 0) !== value)) {\n      throw new Error(`value must be a small positive integer: ${value}`)\n    }\n    this.value = value\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @returns {string} Formated string of `simple(value)`.\n   */\n  toString() {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Debug string for simple value.\n   *\n   * @param {number} depth How deep are we?\n   * @param {object} opts Options.\n   * @returns {string} Formatted string of `simple(value)`.\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, opts) {\n    return `simple(${this.value})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)\n  }\n\n  /**\n   * Is the given object a Simple?\n   *\n   * @param {any} obj Object to test.\n   * @returns {boolean} Is it Simple?\n   */\n  static isSimple(obj) {\n    return obj instanceof Simple\n  }\n\n  /**\n   * Decode from the CBOR additional information into a JavaScript value.\n   * If the CBOR item has no parent, return a \"safe\" symbol instead of\n   * `null` or `undefined`, so that the value can be passed through a\n   * stream in object mode.\n   *\n   * @param {number} val The CBOR additional info to convert.\n   * @param {boolean} [has_parent=true] Does the CBOR item have a parent?\n   * @param {boolean} [parent_indefinite=false] Is the parent element\n   *   indefinitely encoded?\n   * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.\n   * @throws {Error} Invalid BREAK.\n   */\n  static decode(val, has_parent = true, parent_indefinite = false) {\n    switch (val) {\n      case SIMPLE.FALSE:\n        return false\n      case SIMPLE.TRUE:\n        return true\n      case SIMPLE.NULL:\n        if (has_parent) {\n          return null\n        }\n        return SYMS.NULL\n      case SIMPLE.UNDEFINED:\n        if (has_parent) {\n          return undefined\n        }\n        return SYMS.UNDEFINED\n      case -1:\n        if (!has_parent || !parent_indefinite) {\n          throw new Error('Invalid BREAK')\n        }\n        return SYMS.BREAK\n      default:\n        return new Simple(val)\n    }\n  }\n}\n\nmodule.exports = Simple\n","'use strict'\n\nconst constants = require('./constants')\nconst utils = require('./utils')\nconst INTERNAL_JSON = Symbol('INTERNAL_JSON')\n\nfunction setBuffersToJSON(obj, fn) {\n  // The data item tagged can be a byte string or any other data item.  In the\n  // latter case, the tag applies to all of the byte string data items\n  // contained in the data item, except for those contained in a nested data\n  // item tagged with an expected conversion.\n  if (utils.isBufferish(obj)) {\n    obj.toJSON = fn\n  } else if (Array.isArray(obj)) {\n    for (const v of obj) {\n      setBuffersToJSON(v, fn)\n    }\n  } else if (obj && (typeof obj === 'object')) {\n    // FFS, complexity in the protocol.\n\n    // There's some circular dependency in here.\n    // eslint-disable-next-line no-use-before-define\n    if (!(obj instanceof Tagged) || (obj.tag < 21) || (obj.tag > 23)) {\n      for (const v of Object.values(obj)) {\n        setBuffersToJSON(v, fn)\n      }\n    }\n  }\n}\n\nfunction b64this() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64(this)\n}\n\nfunction b64urlThis() {\n  // eslint-disable-next-line no-invalid-this\n  return utils.base64url(this)\n}\n\nfunction hexThis() {\n  // eslint-disable-next-line no-invalid-this\n  return this.toString('hex')\n}\n\nfunction swapEndian(ab, size, byteOffset, byteLength) {\n  const dv = new DataView(ab)\n  const [getter, setter] = {\n    2: [dv.getUint16, dv.setUint16],\n    4: [dv.getUint32, dv.setUint32],\n    8: [dv.getBigUint64, dv.setBigUint64],\n  }[size]\n\n  const end = byteOffset + byteLength\n  for (let offset = byteOffset; offset < end; offset += size) {\n    setter.call(dv, offset, getter.call(dv, offset, true))\n  }\n}\n\n/**\n * Convert a tagged value to a more interesting JavaScript type.  Errors\n * thrown in this function will be captured into the \"err\" property of the\n * original Tagged instance.\n *\n * @callback TagFunction\n * @param {any} value The value inside the tag.\n * @param {Tagged} tag The enclosing Tagged instance; useful if you want to\n *   modify it and return it.  Also available as \"this\".\n * @returns {any} The transformed value.\n */\n\n/* eslint-disable jsdoc/check-types */\n/**\n * A mapping from tag number to a tag decoding function.\n *\n * @typedef {Object.<string, TagFunction>} TagMap\n */\n/* eslint-enable jsdoc/check-types */\n\n/**\n * @type {TagMap}\n * @private\n */\nconst TAGS = {\n  // Standard date/time string; see Section 3.4.1\n  0: v => new Date(v),\n  // Epoch-based date/time; see Section 3.4.2\n  1: v => new Date(v * 1000),\n  // Positive bignum; see Section 3.4.3\n  2: v => utils.bufferToBigInt(v),\n  // Negative bignum; see Section 3.4.3\n  3: v => constants.BI.MINUS_ONE - utils.bufferToBigInt(v),\n  // Expected conversion to base64url encoding; see Section 3.4.5.2\n  21: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64urlThis\n    } else {\n      setBuffersToJSON(v, b64urlThis)\n    }\n    return tag\n  },\n  // Expected conversion to base64 encoding; see Section 3.4.5.2\n  22: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = b64this\n    } else {\n      setBuffersToJSON(v, b64this)\n    }\n    return tag\n  },\n  // Expected conversion to base16 encoding; see Section Section 3.4.5.2\n  23: (v, tag) => {\n    if (utils.isBufferish(v)) {\n      tag[INTERNAL_JSON] = hexThis\n    } else {\n      setBuffersToJSON(v, hexThis)\n    }\n    return tag\n  },\n  // URI; see Section 3.4.5.3\n  32: v => new URL(v),\n  // Base64url; see Section 3.4.5.3\n  33: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {\n      throw new Error('Invalid base64url characters')\n    }\n    const last = v.length % 4\n    if (last === 1) {\n      throw new Error('Invalid base64url length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (last === 2) {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (last === 3) {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    //    Or\n    // -  the base64url encoding has padding characters,\n    // (caught above)\n\n    // the string is invalid.\n    return tag\n  },\n  // Base64; see Section 3.4.5.3\n  34: (v, tag) => {\n    // If any of the following apply:\n    // -  the encoded text string contains non-alphabet characters or\n    //    only 1 alphabet character in the last block of 4 (where\n    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33\n    //    and Section 4 of [RFC4648] for tag number 34), or\n    const m = v.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/)\n    if (!m) {\n      throw new Error('Invalid base64 characters')\n    }\n    if ((v.length % 4) !== 0) {\n      throw new Error('Invalid base64 length')\n    }\n    // -  the padding bits in a 2- or 3-character block are not 0, or\n    if (m.groups.padding === '=') {\n      // The last 4 bits of the last character need to be zero.\n      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    } else if (m.groups.padding === '==') {\n      // The last 2 bits of the last character need to be zero.\n      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {\n        throw new Error('Invalid base64 padding')\n      }\n    }\n\n    // -  the base64 encoding has the wrong number of padding characters,\n    // (caught above)\n    // the string is invalid.\n    return tag\n  },\n  // Regular expression; see Section 2.4.4.3\n  35: v => new RegExp(v),\n  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n  258: v => new Set(v),\n}\n\nconst TYPED_ARRAY_TAGS = {\n  64: Uint8Array,\n  65: Uint16Array,\n  66: Uint32Array,\n  // 67: BigUint64Array,  Safari doesn't implement\n  68: Uint8ClampedArray,\n  69: Uint16Array,\n  70: Uint32Array,\n  // 71: BigUint64Array,  Safari doesn't implement\n  72: Int8Array,\n  73: Int16Array,\n  74: Int32Array,\n  // 75: BigInt64Array,  Safari doesn't implement\n  // 76: reserved\n  77: Int16Array,\n  78: Int32Array,\n  // 79: BigInt64Array,  Safari doesn't implement\n  // 80: not implemented, float16 array\n  81: Float32Array,\n  82: Float64Array,\n  // 83: not implemented, float128 array\n  // 84: not implemented, float16 array\n  85: Float32Array,\n  86: Float64Array,\n  // 87: not implemented, float128 array\n}\n\n// Safari\nif (typeof BigUint64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[67] = BigUint64Array\n  TYPED_ARRAY_TAGS[71] = BigUint64Array\n}\nif (typeof BigInt64Array !== 'undefined') {\n  TYPED_ARRAY_TAGS[75] = BigInt64Array\n  TYPED_ARRAY_TAGS[79] = BigInt64Array\n}\n\nfunction _toTypedArray(val, tagged) {\n  if (!utils.isBufferish(val)) {\n    throw new TypeError('val not a buffer')\n  }\n  const {tag} = tagged\n  // See https://tools.ietf.org/html/rfc8746\n  const TypedClass = TYPED_ARRAY_TAGS[tag]\n  if (!TypedClass) {\n    throw new Error(`Invalid typed array tag: ${tag}`)\n  }\n  const little = tag & 0b00000100\n  const float = (tag & 0b00010000) >> 4\n  const sz = 2 ** (float + (tag & 0b00000011))\n\n  if ((!little !== utils.isBigEndian()) && (sz > 1)) {\n    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength)\n  }\n\n  const ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength)\n  return new TypedClass(ab)\n}\n\nfor (const n of Object.keys(TYPED_ARRAY_TAGS)) {\n  TAGS[n] = _toTypedArray\n}\n\n/**\n * @type {TagMap}\n * @private\n */\nlet current_TAGS = {}\n\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag The number of the tag.\n   * @param {any} value The value inside the tag.\n   * @param {Error} [err] The error that was thrown parsing the tag, or null.\n   */\n  constructor(tag, value, err) {\n    this.tag = tag\n    this.value = value\n    this.err = err\n    if (typeof this.tag !== 'number') {\n      throw new Error(`Invalid tag type (${typeof this.tag})`)\n    }\n    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {\n      throw new Error(`Tag must be a positive integer: ${this.tag}`)\n    }\n  }\n\n  toJSON() {\n    if (this[INTERNAL_JSON]) {\n      return this[INTERNAL_JSON].call(this.value)\n    }\n    const ret = {\n      tag: this.tag,\n      value: this.value,\n    }\n    if (this.err) {\n      ret.err = this.err\n    }\n    return ret\n  }\n\n  /**\n   * Convert to a String.\n   *\n   * @returns {string} String of the form '1(2)'.\n   */\n  toString() {\n    return `${this.tag}(${JSON.stringify(this.value)})`\n  }\n\n  /**\n   * Push the simple value onto the CBOR stream.\n   *\n   * @param {object} gen The generator to push onto.\n   * @returns {boolean} True on success.\n   */\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag)\n    return gen.pushAny(this.value)\n  }\n\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {object} converters Keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} The converted item.\n   */\n  convert(converters) {\n    let f = (converters == null) ? undefined : converters[this.tag]\n    if (f === null) { // === is intentional. null has semantic meaning as above\n      return this\n    }\n    if (typeof f !== 'function') {\n      f = Tagged.TAGS[this.tag]\n      if (typeof f !== 'function') {\n        return this\n      }\n    }\n    try {\n      return f.call(this, this.value, this)\n    } catch (error) {\n      if (error && error.message && (error.message.length > 0)) {\n        this.err = error.message\n      } else {\n        this.err = error\n      }\n      return this\n    }\n  }\n\n  /**\n   * The current set of supported tags.  May be modified by plugins.\n   *\n   * @type {TagMap}\n   * @static\n   */\n  static get TAGS() {\n    return current_TAGS\n  }\n\n  static set TAGS(val) {\n    current_TAGS = val\n  }\n\n  /**\n   * Reset the supported tags to the original set, before any plugins modified\n   * the list.\n   */\n  static reset() {\n    Tagged.TAGS = {...TAGS}\n  }\n}\nTagged.INTERNAL_JSON = INTERNAL_JSON\nTagged.reset()\nmodule.exports = Tagged\n","'use strict'\n\nconst {Buffer} = require('buffer')\nconst NoFilter = require('nofilter')\nconst stream = require('stream')\nconst constants = require('./constants')\nconst {NUMBYTES, SHIFT32, BI, SYMS} = constants\nconst MAX_SAFE_HIGH = 0x1fffff\n\n/**\n * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error\n * on invalid UTF8.  Byte Order Marks are not looked at or stripped.\n *\n * @private\n */\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\nexports.utf8 = buf => td.decode(buf)\nexports.utf8.checksUTF8 = true\n\nfunction isReadable(s) {\n  // Is this a readable stream?  In the webpack version, instanceof isn't\n  // working correctly.\n  if (s instanceof stream.Readable) {\n    return true\n  }\n  return ['read', 'on', 'pipe'].every(f => typeof s[f] === 'function')\n}\n\nexports.isBufferish = function isBufferish(b) {\n  return b &&\n    (typeof b === 'object') &&\n    ((Buffer.isBuffer(b)) ||\n      (b instanceof Uint8Array) ||\n      (b instanceof Uint8ClampedArray) ||\n      (b instanceof ArrayBuffer) ||\n      (b instanceof DataView))\n}\n\nexports.bufferishToBuffer = function bufferishToBuffer(b) {\n  if (Buffer.isBuffer(b)) {\n    return b\n  } else if (ArrayBuffer.isView(b)) {\n    return Buffer.from(b.buffer, b.byteOffset, b.byteLength)\n  } else if (b instanceof ArrayBuffer) {\n    return Buffer.from(b)\n  }\n  return null\n}\n\nexports.parseCBORint = function parseCBORint(ai, buf) {\n  switch (ai) {\n    case NUMBYTES.ONE:\n      return buf.readUInt8(0)\n    case NUMBYTES.TWO:\n      return buf.readUInt16BE(0)\n    case NUMBYTES.FOUR:\n      return buf.readUInt32BE(0)\n    case NUMBYTES.EIGHT: {\n      const f = buf.readUInt32BE(0)\n      const g = buf.readUInt32BE(4)\n      if (f > MAX_SAFE_HIGH) {\n        return (BigInt(f) * BI.SHIFT32) + BigInt(g)\n      }\n      return (f * SHIFT32) + g\n    }\n    default:\n      throw new Error(`Invalid additional info for int: ${ai}`)\n  }\n}\n\nexports.writeHalf = function writeHalf(buf, half) {\n  // Assume 0, -0, NaN, Infinity, and -Infinity have already been caught\n\n  // HACK: everyone settle in.  This isn't going to be pretty.\n  // Translate cn-cbor's C code (from Carsten Borman):\n\n  // uint32_t be32;\n  // uint16_t be16, u16;\n  // union {\n  //   float f;\n  //   uint32_t u;\n  // } u32;\n  // u32.f = float_val;\n\n  const u32 = Buffer.allocUnsafe(4)\n  u32.writeFloatBE(half, 0)\n  const u = u32.readUInt32BE(0)\n\n  // If ((u32.u & 0x1FFF) == 0) { /* worth trying half */\n\n  // hildjj: If the lower 13 bits aren't 0,\n  // we will lose precision in the conversion.\n  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13\n  if ((u & 0x1FFF) !== 0) {\n    return false\n  }\n\n  // Sign, exponent, mantissa\n  //   int s16 = (u32.u >> 16) & 0x8000;\n  //   int exp = (u32.u >> 23) & 0xff;\n  //   int mant = u32.u & 0x7fffff;\n\n  let s16 = (u >> 16) & 0x8000 // Top bit is sign\n  const exp = (u >> 23) & 0xff // Then 5 bits of exponent\n  const mant = u & 0x7fffff\n\n  // Hildjj: zeros already handled.  Assert if you don't believe me.\n  //   if (exp == 0 && mant == 0)\n  //     ;              /* 0.0, -0.0 */\n\n  //   else if (exp >= 113 && exp <= 142) /* normalized */\n  //     s16 += ((exp - 112) << 10) + (mant >> 13);\n\n  if ((exp >= 113) && (exp <= 142)) {\n    s16 += ((exp - 112) << 10) + (mant >> 13)\n  } else if ((exp >= 103) && (exp < 113)) {\n    // Denormalized numbers\n    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */\n    //     if (mant & ((1 << (126 - exp)) - 1))\n    //       goto float32;         /* loss of precision */\n    //     s16 += ((mant + 0x800000) >> (126 - exp));\n\n    if (mant & ((1 << (126 - exp)) - 1)) {\n      return false\n    }\n    s16 += ((mant + 0x800000) >> (126 - exp))\n  } else {\n  //   } else if (exp == 255 && mant == 0) { /* Inf */\n  //     s16 += 0x7c00;\n\n    // hildjj: Infinity already handled\n\n    //   } else\n    //     goto float32;           /* loss of range */\n\n    return false\n  }\n\n  // Done\n  //   ensure_writable(3);\n  //   u16 = s16;\n  //   be16 = hton16p((const uint8_t*)&u16);\n  buf.writeUInt16BE(s16)\n  return true\n}\n\nexports.parseHalf = function parseHalf(buf) {\n  const sign = buf[0] & 0x80 ? -1 : 1\n  const exp = (buf[0] & 0x7C) >> 2\n  const mant = ((buf[0] & 0x03) << 8) | buf[1]\n  if (!exp) {\n    return sign * 5.9604644775390625e-8 * mant\n  } else if (exp === 0x1f) {\n    return sign * (mant ? NaN : Infinity)\n  }\n  return sign * (2 ** (exp - 25)) * (1024 + mant)\n}\n\nexports.parseCBORfloat = function parseCBORfloat(buf) {\n  switch (buf.length) {\n    case 2:\n      return exports.parseHalf(buf)\n    case 4:\n      return buf.readFloatBE(0)\n    case 8:\n      return buf.readDoubleBE(0)\n    default:\n      throw new Error(`Invalid float size: ${buf.length}`)\n  }\n}\n\nexports.hex = function hex(s) {\n  return Buffer.from(s.replace(/^0x/, ''), 'hex')\n}\n\nexports.bin = function bin(s) {\n  s = s.replace(/\\s/g, '')\n  let start = 0\n  let end = (s.length % 8) || 8\n  const chunks = []\n  while (end <= s.length) {\n    chunks.push(parseInt(s.slice(start, end), 2))\n    start = end\n    end += 8\n  }\n  return Buffer.from(chunks)\n}\n\nexports.arrayEqual = function arrayEqual(a, b) {\n  if ((a == null) && (b == null)) {\n    return true\n  }\n  if ((a == null) || (b == null)) {\n    return false\n  }\n  return (a.length === b.length) && a.every((elem, i) => elem === b[i])\n}\n\nexports.bufferToBigInt = function bufferToBigInt(buf) {\n  return BigInt(`0x${buf.toString('hex')}`)\n}\n\nexports.cborValueToString = function cborValueToString(val, float_bytes = -1) {\n  switch (typeof val) {\n    case 'symbol': {\n      switch (val) {\n        case SYMS.NULL:\n          return 'null'\n        case SYMS.UNDEFINED:\n          return 'undefined'\n        case SYMS.BREAK:\n          return 'BREAK'\n      }\n      // Impossible in node 10\n      /* istanbul ignore if */\n      if (val.description) {\n        return val.description\n      }\n      // On node10, Symbol doesn't have description.  Parse it out of the\n      // toString value, which looks like `Symbol(foo)`.\n      const s = val.toString()\n      const m = s.match(/^Symbol\\((?<name>.*)\\)/)\n      /* istanbul ignore if */\n      if (m && m.groups.name) {\n        // Impossible in node 12+\n        /* istanbul ignore next */\n        return m.groups.name\n      }\n      return 'Symbol'\n    }\n    case 'string':\n      return JSON.stringify(val)\n    case 'bigint':\n      return val.toString()\n    case 'number': {\n      const s = Object.is(val, -0) ? '-0' : String(val)\n      return (float_bytes > 0) ? `${s}_${float_bytes}` : s\n    }\n    case 'object': {\n      if (!val) {\n        return 'null'\n      }\n      const buf = exports.bufferishToBuffer(val)\n      if (buf) {\n        const hex = buf.toString('hex')\n        return (float_bytes === -Infinity) ? hex : `h'${hex}'`\n      }\n      if (val && typeof val[Symbol.for('nodejs.util.inspect.custom')] === 'function') {\n        return val[Symbol.for('nodejs.util.inspect.custom')]()\n      }\n      // Shouldn't get non-empty arrays here\n      if (Array.isArray(val)) {\n        return '[]'\n      }\n      // This should be all that is left\n      return '{}'\n    }\n  }\n  return String(val)\n}\n\nexports.guessEncoding = function guessEncoding(input, encoding) {\n  if (typeof input === 'string') {\n    return new NoFilter(input, (encoding == null) ? 'hex' : encoding)\n  }\n  const buf = exports.bufferishToBuffer(input)\n  if (buf) {\n    return new NoFilter(buf)\n  }\n  if (isReadable(input)) {\n    return input\n  }\n  throw new Error('Unknown input type')\n}\n\nconst B64URL_SWAPS = {\n  '=': '',\n  '+': '-',\n  '/': '_',\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64url string.\n * @private\n */\nexports.base64url = function base64url(buf) {\n  return exports.bufferishToBuffer(buf)\n    .toString('base64')\n    .replace(/[=+/]/g, c => B64URL_SWAPS[c])\n}\n\n/**\n * @param {Buffer|Uint8Array|Uint8ClampedArray|ArrayBuffer|DataView} buf\n *   Buffer to convert.\n * @returns {string} Base64 string.\n * @private\n */\nexports.base64 = function base64(buf) {\n  return exports.bufferishToBuffer(buf).toString('base64')\n}\n\nexports.isBigEndian = function isBigEndian() {\n  const array = new Uint8Array(4)\n  const view = new Uint32Array(array.buffer)\n  return !((view[0] = 1) & array[0])\n}\n","// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n\n// binary-parse-stream is now unmaintained, so I have rewritten it as\n// more modern JS so I can get tsc to help check types.\n\n'use strict'\nconst stream = require('stream')\nconst NoFilter = require('nofilter')\n\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @extends stream.Transform\n */\nclass BinaryParseStream extends stream.Transform {\n  /**\n   * Creates an instance of BinaryParseStream.\n   *\n   * @memberof BinaryParseStream\n   * @param {stream.TransformOptions} options Stream options.\n   */\n  constructor(options) {\n    super(options)\n    // Doesn't work to pass these in as opts, for some reason\n    // also, work around typescript not knowing TransformStream internals\n    // eslint-disable-next-line dot-notation\n    this['_writableState'].objectMode = false\n    // eslint-disable-next-line dot-notation\n    this['_readableState'].objectMode = true\n\n    this.bs = new NoFilter()\n    this.__restart()\n  }\n\n  /**\n   * Transforming.\n   *\n   * @param {any} fresh Buffer to transcode.\n   * @param {BufferEncoding} encoding Name of encoding.\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh)\n\n    while (this.bs.length >= this.__needed) {\n      let ret = null\n      const chunk = (this.__needed === null) ?\n        undefined :\n        this.bs.read(this.__needed)\n\n      try {\n        ret = this.__parser.next(chunk)\n      } catch (e) {\n        return cb(e)\n      }\n\n      if (this.__needed) {\n        this.__fresh = false\n      }\n\n      if (ret.done) {\n        this.push(ret.value)\n        this.__restart()\n      } else {\n        this.__needed = ret.value || Infinity\n      }\n    }\n\n    return cb()\n  }\n\n  /**\n   * Subclasses must override this to set their parsing behavior.  Yield a\n   * number to receive a Buffer of that many bytes.\n   *\n   * @abstract\n   * @returns {Generator<number, any, Buffer>}\n   */\n  /* istanbul ignore next */\n  *_parse() { // eslint-disable-line class-methods-use-this, require-yield\n    throw new Error('Must be implemented in subclass')\n  }\n\n  __restart() {\n    this.__needed = null\n    this.__parser = this._parse()\n    this.__fresh = true\n  }\n\n  /**\n   * Flushing.\n   *\n   * @param {stream.TransformCallback} cb Callback when done.\n   * @ignore\n   */\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'))\n  }\n}\n\nmodule.exports = BinaryParseStream\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict'\n\nconst stream = require('stream')\nconst {Buffer} = require('buffer')\nconst td = new TextDecoder('utf8', {fatal: true, ignoreBOM: true})\n\n/**\n * @typedef {object} NoFilterOptions\n * @property {string|Buffer} [input=null] Input source data.\n * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,\n *   ignored if input is not a String.\n * @property {number} [highWaterMark=16384] The maximum number of bytes to\n *   store in the internal buffer before ceasing to read from the underlying\n *   resource. Default=16kb, or 16 for objectMode streams.\n * @property {BufferEncoding} [encoding=null] If specified, then buffers\n *   will be decoded to strings using the specified encoding.\n * @property {boolean} [objectMode=false] Whether this stream should behave\n *   as a stream of objects. Meaning that stream.read(n) returns a single\n *   value instead of a Buffer of size n.\n * @property {boolean} [decodeStrings=true] Whether or not to decode\n *   strings into Buffers before passing them to _write().\n * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,\n *   setting this stream's objectMode based on the objectMode of the input\n *   stream.\n * @property {boolean} [readError=false] If true, when a read() underflows,\n *   throw an error.\n * @property {boolean} [allowHalfOpen=true] If set to false, then the\n *   stream will automatically end the writable side when the readable side\n *   ends.\n * @property {boolean} [autoDestroy=true] Whether this stream should\n *   automatically call .destroy() on itself after ending.\n * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding\n *   that is used when no encoding is specified as an argument to\n *   stream.write().\n * @property {boolean} [emitClose=true] Whether or not the stream should\n *   emit 'close' after it has been destroyed.\n * @property {number} [readableHighWaterMark] Sets highWaterMark for the\n *   readable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [readableObjectMode=false] Sets objectMode for\n *   readable side of the stream. Has no effect if objectMode is true.\n * @property {number} [writableHighWaterMark] Sets highWaterMark for the\n *   writable side of the stream. Has no effect if highWaterMark is provided.\n * @property {boolean} [writableObjectMode=false] Sets objectMode for\n *   writable side of the stream. Has no effect if objectMode is true.\n */\n\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source and sink</caption>\n * const source = new NoFilter('Zm9v', 'base64')\n * source.pipe(process.stdout)\n * const sink = new Nofilter()\n * // NOTE: 'finish' fires when the input is done writing\n * sink.on('finish', () => console.log(n.toString('base64')))\n * process.stdin.pipe(sink)\n */\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.\n   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding\n   *   name for input, ignored if input is not a String.\n   * @param {NoFilterOptions} [options] Other options.\n   */\n  constructor(input, inputEncoding, options = {}) {\n    let inp = null\n    let inpE = /** @type {BufferEncoding?} */ (null)\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input\n        } else if (input) {\n          options = input\n        }\n        break\n      case 'string':\n        inp = input\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid input')\n    }\n    switch (typeof inputEncoding) {\n      case 'object':\n        if (inputEncoding) {\n          options = inputEncoding\n        }\n        break\n      case 'string':\n        inpE = /** @type {BufferEncoding} */ (inputEncoding)\n        break\n      case 'undefined':\n        break\n      default:\n        throw new TypeError('Invalid inputEncoding')\n    }\n    if (!options || typeof options !== 'object') {\n      throw new TypeError('Invalid options')\n    }\n    if (inp == null) {\n      inp = options.input\n    }\n    if (inpE == null) {\n      inpE = options.inputEncoding\n    }\n    delete options.input\n    delete options.inputEncoding\n    const watchPipe = options.watchPipe == null ? true : options.watchPipe\n    delete options.watchPipe\n    const readError = Boolean(options.readError)\n    delete options.readError\n    super(options)\n\n    this.readError = readError\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        // @ts-ignore: TS2339 (using internal interface)\n        const om = readable._readableState.objectMode\n        // @ts-ignore: TS2339 (using internal interface)\n        if ((this.length > 0) && (om !== this._readableState.objectMode)) {\n          throw new Error(\n            'Do not switch objectMode in the middle of the stream'\n          )\n        }\n\n        // @ts-ignore: TS2339 (using internal interface)\n        this._readableState.objectMode = om\n        // @ts-ignore: TS2339 (using internal interface)\n        this._writableState.objectMode = om\n      })\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE)\n    }\n  }\n\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {object} obj The object to test.\n   * @returns {boolean} True if obj is a NoFilter.\n   */\n  static isNoFilter(obj) {\n    return obj instanceof this\n  }\n\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 The first object to compare.\n   * @param {NoFilter} nf2 The second object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments not NoFilter instances.\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')]\n   * arr.sort(NoFilter.compare)\n   */\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (nf1 === nf2) {\n      return 0\n    }\n    return nf1.compare(nf2)\n  }\n\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read.\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer.\n   * @throws {TypeError} List not array of NoFilters.\n   */\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters')\n    }\n    if ((list.length === 0) || (length === 0)) {\n      return Buffer.alloc(0)\n    }\n    if ((length == null)) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters')\n        }\n        return tot + nf.length\n      }, 0)\n    }\n    let allBufs = true\n    let allObjs = true\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters')\n      }\n      const buf = nf.slice()\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false\n      } else {\n        allBufs = false\n      }\n      return buf\n    })\n    if (allBufs) {\n      // @ts-ignore: TS2322, tsc can't see the type checking above\n      return Buffer.concat(bufs, length)\n    }\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length)\n    }\n    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n    throw new Error('Concatenating mixed object and byte streams not supported')\n  }\n\n  /**\n   * @ignore\n   */\n  _transform(chunk, encoding, callback) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    this.push(chunk)\n    callback()\n  }\n\n  /**\n   * @returns {Buffer[]} The current internal buffers.  They are layed out\n   *   end to end.\n   * @ignore\n   */\n  _bufArray() {\n    // @ts-ignore: TS2339 (using internal interface)\n    let bufs = this._readableState.buffer\n    // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head\n      bufs = []\n      while (b != null) {\n        bufs.push(b.data)\n        b = b.next\n      }\n    }\n    return bufs\n  }\n\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer.\n   * @throws Error If readError is true and there was underflow.\n   * @fires NoFilter#read When read from.\n   */\n  read(size) {\n    const buf = super.read(size)\n    if (buf != null) {\n      /**\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @param {Buffer|string|object} buf What was read.\n       */\n      this.emit('read', buf)\n      if (this.readError && (buf.length < size)) {\n        throw new Error(`Read ${buf.length}, wanted ${size}`)\n      }\n    } else if (this.readError) {\n      throw new Error(`No data available, wanted ${size}`)\n    }\n    return buf\n  }\n\n  /**\n   * Read the full number of bytes asked for, no matter how long it takes.\n   * Fail if an error occurs in the meantime, or if the stream finishes before\n   * enough data is available.\n   *\n   * Note: This function won't work fully correctly if you are using\n   * stream-browserify (for example, on the Web).\n   *\n   * @param {number} size The number of bytes to read.\n   * @returns {Promise<string|Buffer>} A promise for the data read.\n   */\n  readFull(size) {\n    let onReadable = null\n    let onFinish = null\n    let onError = null\n    return new Promise((resolve, reject) => {\n      if (this.length >= size) {\n        resolve(this.read(size))\n        return\n      }\n\n      // Added in Node 12.19.  This won't work with stream-browserify yet.\n      // If it's needed, file a bug, and I'll do a work-around.\n      if (this.writableFinished) {\n        // Already finished writing, so no more coming.\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n        return\n      }\n\n      onReadable = chunk => {\n        if (this.length >= size) {\n          resolve(this.read(size))\n        }\n      }\n      onFinish = () => {\n        reject(new Error(`Stream finished before ${size} bytes were available`))\n      }\n      onError = reject\n      this.on('readable', onReadable)\n      this.on('error', onError)\n      this.on('finish', onFinish)\n    }).finally(() => {\n      if (onReadable) {\n        this.removeListener('readable', onReadable)\n        this.removeListener('error', onError)\n        this.removeListener('finish', onFinish)\n      }\n    })\n  }\n\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {Function} [cb=null] Finished/error callback used in *addition*\n   *   to the promise.\n   * @returns {Promise<Buffer|string>} Fulfilled when complete.\n   */\n  promise(cb) {\n    let done = false\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read()\n        if ((cb != null) && !done) {\n          done = true\n          cb(null, data)\n        }\n        resolve(data)\n      })\n      this.on('error', er => {\n        if ((cb != null) && !done) {\n          done = true\n          cb(er)\n        }\n        reject(er)\n      })\n    })\n  }\n\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other The other object to compare.\n   * @returns {number} -1, 0, 1 for less, equal, greater.\n   * @throws {TypeError} Arguments must be NoFilters.\n   */\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters')\n    }\n    if (this === other) {\n      return 0\n    }\n\n    const buf1 = this.slice()\n    const buf2 = other.slice()\n    // These will both be buffers because of the check above.\n    if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n      return buf1.compare(buf2)\n    }\n    throw new Error('Cannot compare streams in object mode')\n  }\n\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other Other NoFilter to compare against.\n   * @returns {boolean} Equal?\n   */\n  equals(other) {\n    return this.compare(other) === 0\n  }\n\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {number} [start=0] Beginning offset.\n   * @param {number} [end=length] Ending offset.\n   * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n  slice(start, end) {\n    // @ts-ignore: TS2339 (using internal interface)\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end)\n    }\n    const bufs = this._bufArray()\n    switch (bufs.length) {\n      case 0: return Buffer.alloc(0)\n      case 1: return bufs[0].slice(start, end)\n      default: {\n        const b = Buffer.concat(bufs)\n        // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n        return b.slice(start, end)\n      }\n    }\n  }\n\n  /**\n   * Get a byte by offset.  I didn't want to get into metaprogramming\n   * to give you the `NoFilter[0]` syntax.\n   *\n   * @param {number} index The byte to retrieve.\n   * @returns {number} 0-255.\n   */\n  get(index) {\n    return this.slice()[index]\n  }\n\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so that\n   * round-tripping will produce a Buffer.\n   *\n   * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,\n   *   the objects.  Otherwise, JSON text.\n   * @example <caption>output for 'foo', not in object mode</caption>\n   * ({\n   *   type: 'Buffer',\n   *   data: [102, 111, 111],\n   * })\n   */\n  toJSON() {\n    const b = this.slice()\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON()\n    }\n    return b\n  }\n\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?\n   * @param {number} [start=0] Start offset.\n   * @param {number} [end=length] End offset.\n   * @returns {string} String version of the contents.\n   */\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end)\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf)\n    }\n    if (!encoding || (encoding === 'utf8')) {\n      return td.decode(buf)\n    }\n    return buf.toString(encoding)\n  }\n\n  /**\n   * @ignore\n   */\n  [Symbol.for('nodejs.util.inspect.custom')](depth, options) {\n    const bufs = this._bufArray()\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        return options.stylize(b.toString('hex'), 'string')\n      }\n      return JSON.stringify(b)\n    }).join(', ')\n    return `${this.constructor.name} [${hex}]`\n  }\n\n  /**\n   * Current readable length, in bytes.\n   *\n   * @returns {number} Length of the contents.\n   */\n  get length() {\n    // @ts-ignore: TS2339 (using internal interface)\n    return this._readableState.length\n  }\n\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val The value to write.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt(val) {\n    let str = val.toString(16)\n    if (val < 0) {\n      // Two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2))\n      const mask = BigInt(1) << (sz * BigInt(8))\n      val = mask + val\n      str = val.toString(16)\n    }\n    if (str.length % 2) {\n      str = `0${str}`\n    }\n    return this.push(Buffer.from(str, 'hex'))\n  }\n\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readUBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return BigInt(`0x${b.toString('hex')}`)\n  }\n\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] Number of bytes to read or all remaining\n   *   if null.\n   * @returns {bigint} A BigInt.\n   */\n  readBigInt(len) {\n    const b = this.read(len)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    let ret = BigInt(`0x${b.toString('hex')}`)\n    // Negative?\n    if (b[0] & 0x80) {\n      // Two's complement\n      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))\n      ret -= mask\n    }\n    return ret\n  }\n\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value 0..255.\n   * @returns {boolean} True on success.\n   */\n  writeUInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @param {number} value 0..65535.\n   * @returns {boolean} True on success.\n   */\n  writeUInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @param {number} value 0..2**32-1.\n   * @returns {boolean} True on success.\n   */\n  writeUInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @param {number} value (-128)..127.\n   * @returns {boolean} True on success.\n   */\n  writeInt8(value) {\n    const b = Buffer.from([value])\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16LE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @param {number} value (-32768)..32767.\n   * @returns {boolean} True on success.\n   */\n  writeInt16BE(value) {\n    const b = Buffer.alloc(2)\n    b.writeUInt16BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32LE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value (-2**31)..(2**31-1).\n   * @returns {boolean} True on success.\n   */\n  writeInt32BE(value) {\n    const b = Buffer.alloc(4)\n    b.writeUInt32BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatLE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @param {number} value 32-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeFloatBE(value) {\n    const b = Buffer.alloc(4)\n    b.writeFloatBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleLE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleLE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @param {number} value 64-bit float.\n   * @returns {boolean} True on success.\n   */\n  writeDoubleBE(value) {\n    const b = Buffer.alloc(8)\n    b.writeDoubleBE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64LE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64LE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.\n   *\n   * @param {bigint} value Non-negative BigInt.\n   * @returns {boolean} True on success.\n   */\n  writeBigUInt64BE(value) {\n    const b = Buffer.alloc(8)\n    b.writeBigUInt64BE(value)\n    return this.push(b)\n  }\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt8()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt16BE()\n  }\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32LE()\n  }\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readUInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readUInt32BE()\n  }\n\n  /**\n   * Read a signed 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @returns {number} Value read.\n   */\n  readInt8() {\n    const b = this.read(1)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt8()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16LE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt16BE() {\n    const b = this.read(2)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt16BE()\n  }\n\n  /**\n   * Read a little-endian signed 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32LE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32LE()\n  }\n\n  /**\n   * Read a little-endian signed 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readInt32BE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readInt32BE()\n  }\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatLE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatLE()\n  }\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readFloatBE() {\n    const b = this.read(4)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readFloatBE()\n  }\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleLE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleLE()\n  }\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {number} Value read.\n   */\n  readDoubleBE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readDoubleBE()\n  }\n\n  /**\n   * Read a signed 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64LE()\n  }\n\n  /**\n   * Read a signed 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigInt64BE()\n  }\n\n  /**\n   * Read an unsigned 64-bit little-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64LE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64LE()\n  }\n\n  /**\n   * Read an unsigned 64-bit big-endian BigInt from the stream.\n   * Consumes 8 bytes.\n   *\n   * @returns {bigint} Value read.\n   */\n  readBigUInt64BE() {\n    const b = this.read(8)\n    if (!Buffer.isBuffer(b)) {\n      return null\n    }\n    return b.readBigUInt64BE()\n  }\n}\n\nmodule.exports = NoFilter\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","//---------------------------------------------------------------------\n//\n// QR Code Generator for JavaScript\n//\n// Copyright (c) 2009 Kazuhiko Arase\n//\n// URL: http://www.d-project.com/\n//\n// Licensed under the MIT license:\n//  http://www.opensource.org/licenses/mit-license.php\n//\n// The word 'QR Code' is registered trademark of\n// DENSO WAVE INCORPORATED\n//  http://www.denso-wave.com/qrcode/faqpatent-e.html\n//\n//---------------------------------------------------------------------\n\nvar qrcode = function() {\n\n  //---------------------------------------------------------------------\n  // qrcode\n  //---------------------------------------------------------------------\n\n  /**\n   * qrcode\n   * @param typeNumber 1 to 40\n   * @param errorCorrectionLevel 'L','M','Q','H'\n   */\n  var qrcode = function(typeNumber, errorCorrectionLevel) {\n\n    var PAD0 = 0xEC;\n    var PAD1 = 0x11;\n\n    var _typeNumber = typeNumber;\n    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];\n    var _modules = null;\n    var _moduleCount = 0;\n    var _dataCache = null;\n    var _dataList = [];\n\n    var _this = {};\n\n    var makeImpl = function(test, maskPattern) {\n\n      _moduleCount = _typeNumber * 4 + 17;\n      _modules = function(moduleCount) {\n        var modules = new Array(moduleCount);\n        for (var row = 0; row < moduleCount; row += 1) {\n          modules[row] = new Array(moduleCount);\n          for (var col = 0; col < moduleCount; col += 1) {\n            modules[row][col] = null;\n          }\n        }\n        return modules;\n      }(_moduleCount);\n\n      setupPositionProbePattern(0, 0);\n      setupPositionProbePattern(_moduleCount - 7, 0);\n      setupPositionProbePattern(0, _moduleCount - 7);\n      setupPositionAdjustPattern();\n      setupTimingPattern();\n      setupTypeInfo(test, maskPattern);\n\n      if (_typeNumber >= 7) {\n        setupTypeNumber(test);\n      }\n\n      if (_dataCache == null) {\n        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n      }\n\n      mapData(_dataCache, maskPattern);\n    };\n\n    var setupPositionProbePattern = function(row, col) {\n\n      for (var r = -1; r <= 7; r += 1) {\n\n        if (row + r <= -1 || _moduleCount <= row + r) continue;\n\n        for (var c = -1; c <= 7; c += 1) {\n\n          if (col + c <= -1 || _moduleCount <= col + c) continue;\n\n          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )\n              || (0 <= c && c <= 6 && (r == 0 || r == 6) )\n              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {\n            _modules[row + r][col + c] = true;\n          } else {\n            _modules[row + r][col + c] = false;\n          }\n        }\n      }\n    };\n\n    var getBestMaskPattern = function() {\n\n      var minLostPoint = 0;\n      var pattern = 0;\n\n      for (var i = 0; i < 8; i += 1) {\n\n        makeImpl(true, i);\n\n        var lostPoint = QRUtil.getLostPoint(_this);\n\n        if (i == 0 || minLostPoint > lostPoint) {\n          minLostPoint = lostPoint;\n          pattern = i;\n        }\n      }\n\n      return pattern;\n    };\n\n    var setupTimingPattern = function() {\n\n      for (var r = 8; r < _moduleCount - 8; r += 1) {\n        if (_modules[r][6] != null) {\n          continue;\n        }\n        _modules[r][6] = (r % 2 == 0);\n      }\n\n      for (var c = 8; c < _moduleCount - 8; c += 1) {\n        if (_modules[6][c] != null) {\n          continue;\n        }\n        _modules[6][c] = (c % 2 == 0);\n      }\n    };\n\n    var setupPositionAdjustPattern = function() {\n\n      var pos = QRUtil.getPatternPosition(_typeNumber);\n\n      for (var i = 0; i < pos.length; i += 1) {\n\n        for (var j = 0; j < pos.length; j += 1) {\n\n          var row = pos[i];\n          var col = pos[j];\n\n          if (_modules[row][col] != null) {\n            continue;\n          }\n\n          for (var r = -2; r <= 2; r += 1) {\n\n            for (var c = -2; c <= 2; c += 1) {\n\n              if (r == -2 || r == 2 || c == -2 || c == 2\n                  || (r == 0 && c == 0) ) {\n                _modules[row + r][col + c] = true;\n              } else {\n                _modules[row + r][col + c] = false;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    var setupTypeNumber = function(test) {\n\n      var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n\n      for (var i = 0; i < 18; i += 1) {\n        var mod = (!test && ( (bits >> i) & 1) == 1);\n        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;\n      }\n\n      for (var i = 0; i < 18; i += 1) {\n        var mod = (!test && ( (bits >> i) & 1) == 1);\n        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;\n      }\n    };\n\n    var setupTypeInfo = function(test, maskPattern) {\n\n      var data = (_errorCorrectionLevel << 3) | maskPattern;\n      var bits = QRUtil.getBCHTypeInfo(data);\n\n      // vertical\n      for (var i = 0; i < 15; i += 1) {\n\n        var mod = (!test && ( (bits >> i) & 1) == 1);\n\n        if (i < 6) {\n          _modules[i][8] = mod;\n        } else if (i < 8) {\n          _modules[i + 1][8] = mod;\n        } else {\n          _modules[_moduleCount - 15 + i][8] = mod;\n        }\n      }\n\n      // horizontal\n      for (var i = 0; i < 15; i += 1) {\n\n        var mod = (!test && ( (bits >> i) & 1) == 1);\n\n        if (i < 8) {\n          _modules[8][_moduleCount - i - 1] = mod;\n        } else if (i < 9) {\n          _modules[8][15 - i - 1 + 1] = mod;\n        } else {\n          _modules[8][15 - i - 1] = mod;\n        }\n      }\n\n      // fixed module\n      _modules[_moduleCount - 8][8] = (!test);\n    };\n\n    var mapData = function(data, maskPattern) {\n\n      var inc = -1;\n      var row = _moduleCount - 1;\n      var bitIndex = 7;\n      var byteIndex = 0;\n      var maskFunc = QRUtil.getMaskFunction(maskPattern);\n\n      for (var col = _moduleCount - 1; col > 0; col -= 2) {\n\n        if (col == 6) col -= 1;\n\n        while (true) {\n\n          for (var c = 0; c < 2; c += 1) {\n\n            if (_modules[row][col - c] == null) {\n\n              var dark = false;\n\n              if (byteIndex < data.length) {\n                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);\n              }\n\n              var mask = maskFunc(row, col - c);\n\n              if (mask) {\n                dark = !dark;\n              }\n\n              _modules[row][col - c] = dark;\n              bitIndex -= 1;\n\n              if (bitIndex == -1) {\n                byteIndex += 1;\n                bitIndex = 7;\n              }\n            }\n          }\n\n          row += inc;\n\n          if (row < 0 || _moduleCount <= row) {\n            row -= inc;\n            inc = -inc;\n            break;\n          }\n        }\n      }\n    };\n\n    var createBytes = function(buffer, rsBlocks) {\n\n      var offset = 0;\n\n      var maxDcCount = 0;\n      var maxEcCount = 0;\n\n      var dcdata = new Array(rsBlocks.length);\n      var ecdata = new Array(rsBlocks.length);\n\n      for (var r = 0; r < rsBlocks.length; r += 1) {\n\n        var dcCount = rsBlocks[r].dataCount;\n        var ecCount = rsBlocks[r].totalCount - dcCount;\n\n        maxDcCount = Math.max(maxDcCount, dcCount);\n        maxEcCount = Math.max(maxEcCount, ecCount);\n\n        dcdata[r] = new Array(dcCount);\n\n        for (var i = 0; i < dcdata[r].length; i += 1) {\n          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];\n        }\n        offset += dcCount;\n\n        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n\n        var modPoly = rawPoly.mod(rsPoly);\n        ecdata[r] = new Array(rsPoly.getLength() - 1);\n        for (var i = 0; i < ecdata[r].length; i += 1) {\n          var modIndex = i + modPoly.getLength() - ecdata[r].length;\n          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;\n        }\n      }\n\n      var totalCodeCount = 0;\n      for (var i = 0; i < rsBlocks.length; i += 1) {\n        totalCodeCount += rsBlocks[i].totalCount;\n      }\n\n      var data = new Array(totalCodeCount);\n      var index = 0;\n\n      for (var i = 0; i < maxDcCount; i += 1) {\n        for (var r = 0; r < rsBlocks.length; r += 1) {\n          if (i < dcdata[r].length) {\n            data[index] = dcdata[r][i];\n            index += 1;\n          }\n        }\n      }\n\n      for (var i = 0; i < maxEcCount; i += 1) {\n        for (var r = 0; r < rsBlocks.length; r += 1) {\n          if (i < ecdata[r].length) {\n            data[index] = ecdata[r][i];\n            index += 1;\n          }\n        }\n      }\n\n      return data;\n    };\n\n    var createData = function(typeNumber, errorCorrectionLevel, dataList) {\n\n      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);\n\n      var buffer = qrBitBuffer();\n\n      for (var i = 0; i < dataList.length; i += 1) {\n        var data = dataList[i];\n        buffer.put(data.getMode(), 4);\n        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );\n        data.write(buffer);\n      }\n\n      // calc num max data.\n      var totalDataCount = 0;\n      for (var i = 0; i < rsBlocks.length; i += 1) {\n        totalDataCount += rsBlocks[i].dataCount;\n      }\n\n      if (buffer.getLengthInBits() > totalDataCount * 8) {\n        throw 'code length overflow. ('\n          + buffer.getLengthInBits()\n          + '>'\n          + totalDataCount * 8\n          + ')';\n      }\n\n      // end code\n      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n        buffer.put(0, 4);\n      }\n\n      // padding\n      while (buffer.getLengthInBits() % 8 != 0) {\n        buffer.putBit(false);\n      }\n\n      // padding\n      while (true) {\n\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\n          break;\n        }\n        buffer.put(PAD0, 8);\n\n        if (buffer.getLengthInBits() >= totalDataCount * 8) {\n          break;\n        }\n        buffer.put(PAD1, 8);\n      }\n\n      return createBytes(buffer, rsBlocks);\n    };\n\n    _this.addData = function(data, mode) {\n\n      mode = mode || 'Byte';\n\n      var newData = null;\n\n      switch(mode) {\n      case 'Numeric' :\n        newData = qrNumber(data);\n        break;\n      case 'Alphanumeric' :\n        newData = qrAlphaNum(data);\n        break;\n      case 'Byte' :\n        newData = qr8BitByte(data);\n        break;\n      case 'Kanji' :\n        newData = qrKanji(data);\n        break;\n      default :\n        throw 'mode:' + mode;\n      }\n\n      _dataList.push(newData);\n      _dataCache = null;\n    };\n\n    _this.isDark = function(row, col) {\n      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n        throw row + ',' + col;\n      }\n      return _modules[row][col];\n    };\n\n    _this.getModuleCount = function() {\n      return _moduleCount;\n    };\n\n    _this.make = function() {\n      if (_typeNumber < 1) {\n        var typeNumber = 1;\n\n        for (; typeNumber < 40; typeNumber++) {\n          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);\n          var buffer = qrBitBuffer();\n\n          for (var i = 0; i < _dataList.length; i++) {\n            var data = _dataList[i];\n            buffer.put(data.getMode(), 4);\n            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );\n            data.write(buffer);\n          }\n\n          var totalDataCount = 0;\n          for (var i = 0; i < rsBlocks.length; i++) {\n            totalDataCount += rsBlocks[i].dataCount;\n          }\n\n          if (buffer.getLengthInBits() <= totalDataCount * 8) {\n            break;\n          }\n        }\n\n        _typeNumber = typeNumber;\n      }\n\n      makeImpl(false, getBestMaskPattern() );\n    };\n\n    _this.createTableTag = function(cellSize, margin) {\n\n      cellSize = cellSize || 2;\n      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;\n\n      var qrHtml = '';\n\n      qrHtml += '<table style=\"';\n      qrHtml += ' border-width: 0px; border-style: none;';\n      qrHtml += ' border-collapse: collapse;';\n      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';\n      qrHtml += '\">';\n      qrHtml += '<tbody>';\n\n      for (var r = 0; r < _this.getModuleCount(); r += 1) {\n\n        qrHtml += '<tr>';\n\n        for (var c = 0; c < _this.getModuleCount(); c += 1) {\n          qrHtml += '<td style=\"';\n          qrHtml += ' border-width: 0px; border-style: none;';\n          qrHtml += ' border-collapse: collapse;';\n          qrHtml += ' padding: 0px; margin: 0px;';\n          qrHtml += ' width: ' + cellSize + 'px;';\n          qrHtml += ' height: ' + cellSize + 'px;';\n          qrHtml += ' background-color: ';\n          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';\n          qrHtml += ';';\n          qrHtml += '\"/>';\n        }\n\n        qrHtml += '</tr>';\n      }\n\n      qrHtml += '</tbody>';\n      qrHtml += '</table>';\n\n      return qrHtml;\n    };\n\n    _this.createSvgTag = function(cellSize, margin, alt, title) {\n\n      var opts = {};\n      if (typeof arguments[0] == 'object') {\n        // Called by options.\n        opts = arguments[0];\n        // overwrite cellSize and margin.\n        cellSize = opts.cellSize;\n        margin = opts.margin;\n        alt = opts.alt;\n        title = opts.title;\n      }\n\n      cellSize = cellSize || 2;\n      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;\n\n      // Compose alt property surrogate\n      alt = (typeof alt === 'string') ? {text: alt} : alt || {};\n      alt.text = alt.text || null;\n      alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;\n\n      // Compose title property surrogate\n      title = (typeof title === 'string') ? {text: title} : title || {};\n      title.text = title.text || null;\n      title.id = (title.text) ? title.id || 'qrcode-title' : null;\n\n      var size = _this.getModuleCount() * cellSize + margin * 2;\n      var c, mc, r, mr, qrSvg='', rect;\n\n      rect = 'l' + cellSize + ',0 0,' + cellSize +\n        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';\n\n      qrSvg += '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"';\n      qrSvg += !opts.scalable ? ' width=\"' + size + 'px\" height=\"' + size + 'px\"' : '';\n      qrSvg += ' viewBox=\"0 0 ' + size + ' ' + size + '\" ';\n      qrSvg += ' preserveAspectRatio=\"xMinYMin meet\"';\n      qrSvg += (title.text || alt.text) ? ' role=\"img\" aria-labelledby=\"' +\n          escapeXml([title.id, alt.id].join(' ').trim() ) + '\"' : '';\n      qrSvg += '>';\n      qrSvg += (title.text) ? '<title id=\"' + escapeXml(title.id) + '\">' +\n          escapeXml(title.text) + '</title>' : '';\n      qrSvg += (alt.text) ? '<description id=\"' + escapeXml(alt.id) + '\">' +\n          escapeXml(alt.text) + '</description>' : '';\n      qrSvg += '<rect width=\"100%\" height=\"100%\" fill=\"white\" cx=\"0\" cy=\"0\"/>';\n      qrSvg += '<path d=\"';\n\n      for (r = 0; r < _this.getModuleCount(); r += 1) {\n        mr = r * cellSize + margin;\n        for (c = 0; c < _this.getModuleCount(); c += 1) {\n          if (_this.isDark(r, c) ) {\n            mc = c*cellSize+margin;\n            qrSvg += 'M' + mc + ',' + mr + rect;\n          }\n        }\n      }\n\n      qrSvg += '\" stroke=\"transparent\" fill=\"black\"/>';\n      qrSvg += '</svg>';\n\n      return qrSvg;\n    };\n\n    _this.createDataURL = function(cellSize, margin) {\n\n      cellSize = cellSize || 2;\n      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;\n\n      var size = _this.getModuleCount() * cellSize + margin * 2;\n      var min = margin;\n      var max = size - margin;\n\n      return createDataURL(size, size, function(x, y) {\n        if (min <= x && x < max && min <= y && y < max) {\n          var c = Math.floor( (x - min) / cellSize);\n          var r = Math.floor( (y - min) / cellSize);\n          return _this.isDark(r, c)? 0 : 1;\n        } else {\n          return 1;\n        }\n      } );\n    };\n\n    _this.createImgTag = function(cellSize, margin, alt) {\n\n      cellSize = cellSize || 2;\n      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;\n\n      var size = _this.getModuleCount() * cellSize + margin * 2;\n\n      var img = '';\n      img += '<img';\n      img += '\\u0020src=\"';\n      img += _this.createDataURL(cellSize, margin);\n      img += '\"';\n      img += '\\u0020width=\"';\n      img += size;\n      img += '\"';\n      img += '\\u0020height=\"';\n      img += size;\n      img += '\"';\n      if (alt) {\n        img += '\\u0020alt=\"';\n        img += escapeXml(alt);\n        img += '\"';\n      }\n      img += '/>';\n\n      return img;\n    };\n\n    var escapeXml = function(s) {\n      var escaped = '';\n      for (var i = 0; i < s.length; i += 1) {\n        var c = s.charAt(i);\n        switch(c) {\n        case '<': escaped += '&lt;'; break;\n        case '>': escaped += '&gt;'; break;\n        case '&': escaped += '&amp;'; break;\n        case '\"': escaped += '&quot;'; break;\n        default : escaped += c; break;\n        }\n      }\n      return escaped;\n    };\n\n    var _createHalfASCII = function(margin) {\n      var cellSize = 1;\n      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;\n\n      var size = _this.getModuleCount() * cellSize + margin * 2;\n      var min = margin;\n      var max = size - margin;\n\n      var y, x, r1, r2, p;\n\n      var blocks = {\n        '': '',\n        ' ': '',\n        ' ': '',\n        '  ': ' '\n      };\n\n      var blocksLastLineNoMargin = {\n        '': '',\n        ' ': '',\n        ' ': ' ',\n        '  ': ' '\n      };\n\n      var ascii = '';\n      for (y = 0; y < size; y += 2) {\n        r1 = Math.floor((y - min) / cellSize);\n        r2 = Math.floor((y + 1 - min) / cellSize);\n        for (x = 0; x < size; x += 1) {\n          p = '';\n\n          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {\n            p = ' ';\n          }\n\n          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {\n            p += ' ';\n          }\n          else {\n            p += '';\n          }\n\n          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.\n          ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];\n        }\n\n        ascii += '\\n';\n      }\n\n      if (size % 2 && margin > 0) {\n        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('');\n      }\n\n      return ascii.substring(0, ascii.length-1);\n    };\n\n    _this.createASCII = function(cellSize, margin) {\n      cellSize = cellSize || 1;\n\n      if (cellSize < 2) {\n        return _createHalfASCII(margin);\n      }\n\n      cellSize -= 1;\n      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;\n\n      var size = _this.getModuleCount() * cellSize + margin * 2;\n      var min = margin;\n      var max = size - margin;\n\n      var y, x, r, p;\n\n      var white = Array(cellSize+1).join('');\n      var black = Array(cellSize+1).join('  ');\n\n      var ascii = '';\n      var line = '';\n      for (y = 0; y < size; y += 1) {\n        r = Math.floor( (y - min) / cellSize);\n        line = '';\n        for (x = 0; x < size; x += 1) {\n          p = 1;\n\n          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {\n            p = 0;\n          }\n\n          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.\n          line += p ? white : black;\n        }\n\n        for (r = 0; r < cellSize; r += 1) {\n          ascii += line + '\\n';\n        }\n      }\n\n      return ascii.substring(0, ascii.length-1);\n    };\n\n    _this.renderTo2dContext = function(context, cellSize) {\n      cellSize = cellSize || 2;\n      var length = _this.getModuleCount();\n      for (var row = 0; row < length; row++) {\n        for (var col = 0; col < length; col++) {\n          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';\n          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // qrcode.stringToBytes\n  //---------------------------------------------------------------------\n\n  qrcode.stringToBytesFuncs = {\n    'default' : function(s) {\n      var bytes = [];\n      for (var i = 0; i < s.length; i += 1) {\n        var c = s.charCodeAt(i);\n        bytes.push(c & 0xff);\n      }\n      return bytes;\n    }\n  };\n\n  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];\n\n  //---------------------------------------------------------------------\n  // qrcode.createStringToBytes\n  //---------------------------------------------------------------------\n\n  /**\n   * @param unicodeData base64 string of byte array.\n   * [16bit Unicode],[16bit Bytes], ...\n   * @param numChars\n   */\n  qrcode.createStringToBytes = function(unicodeData, numChars) {\n\n    // create conversion map.\n\n    var unicodeMap = function() {\n\n      var bin = base64DecodeInputStream(unicodeData);\n      var read = function() {\n        var b = bin.read();\n        if (b == -1) throw 'eof';\n        return b;\n      };\n\n      var count = 0;\n      var unicodeMap = {};\n      while (true) {\n        var b0 = bin.read();\n        if (b0 == -1) break;\n        var b1 = read();\n        var b2 = read();\n        var b3 = read();\n        var k = String.fromCharCode( (b0 << 8) | b1);\n        var v = (b2 << 8) | b3;\n        unicodeMap[k] = v;\n        count += 1;\n      }\n      if (count != numChars) {\n        throw count + ' != ' + numChars;\n      }\n\n      return unicodeMap;\n    }();\n\n    var unknownChar = '?'.charCodeAt(0);\n\n    return function(s) {\n      var bytes = [];\n      for (var i = 0; i < s.length; i += 1) {\n        var c = s.charCodeAt(i);\n        if (c < 128) {\n          bytes.push(c);\n        } else {\n          var b = unicodeMap[s.charAt(i)];\n          if (typeof b == 'number') {\n            if ( (b & 0xff) == b) {\n              // 1byte\n              bytes.push(b);\n            } else {\n              // 2bytes\n              bytes.push(b >>> 8);\n              bytes.push(b & 0xff);\n            }\n          } else {\n            bytes.push(unknownChar);\n          }\n        }\n      }\n      return bytes;\n    };\n  };\n\n  //---------------------------------------------------------------------\n  // QRMode\n  //---------------------------------------------------------------------\n\n  var QRMode = {\n    MODE_NUMBER :    1 << 0,\n    MODE_ALPHA_NUM : 1 << 1,\n    MODE_8BIT_BYTE : 1 << 2,\n    MODE_KANJI :     1 << 3\n  };\n\n  //---------------------------------------------------------------------\n  // QRErrorCorrectionLevel\n  //---------------------------------------------------------------------\n\n  var QRErrorCorrectionLevel = {\n    L : 1,\n    M : 0,\n    Q : 3,\n    H : 2\n  };\n\n  //---------------------------------------------------------------------\n  // QRMaskPattern\n  //---------------------------------------------------------------------\n\n  var QRMaskPattern = {\n    PATTERN000 : 0,\n    PATTERN001 : 1,\n    PATTERN010 : 2,\n    PATTERN011 : 3,\n    PATTERN100 : 4,\n    PATTERN101 : 5,\n    PATTERN110 : 6,\n    PATTERN111 : 7\n  };\n\n  //---------------------------------------------------------------------\n  // QRUtil\n  //---------------------------------------------------------------------\n\n  var QRUtil = function() {\n\n    var PATTERN_POSITION_TABLE = [\n      [],\n      [6, 18],\n      [6, 22],\n      [6, 26],\n      [6, 30],\n      [6, 34],\n      [6, 22, 38],\n      [6, 24, 42],\n      [6, 26, 46],\n      [6, 28, 50],\n      [6, 30, 54],\n      [6, 32, 58],\n      [6, 34, 62],\n      [6, 26, 46, 66],\n      [6, 26, 48, 70],\n      [6, 26, 50, 74],\n      [6, 30, 54, 78],\n      [6, 30, 56, 82],\n      [6, 30, 58, 86],\n      [6, 34, 62, 90],\n      [6, 28, 50, 72, 94],\n      [6, 26, 50, 74, 98],\n      [6, 30, 54, 78, 102],\n      [6, 28, 54, 80, 106],\n      [6, 32, 58, 84, 110],\n      [6, 30, 58, 86, 114],\n      [6, 34, 62, 90, 118],\n      [6, 26, 50, 74, 98, 122],\n      [6, 30, 54, 78, 102, 126],\n      [6, 26, 52, 78, 104, 130],\n      [6, 30, 56, 82, 108, 134],\n      [6, 34, 60, 86, 112, 138],\n      [6, 30, 58, 86, 114, 142],\n      [6, 34, 62, 90, 118, 146],\n      [6, 30, 54, 78, 102, 126, 150],\n      [6, 24, 50, 76, 102, 128, 154],\n      [6, 28, 54, 80, 106, 132, 158],\n      [6, 32, 58, 84, 110, 136, 162],\n      [6, 26, 54, 82, 110, 138, 166],\n      [6, 30, 58, 86, 114, 142, 170]\n    ];\n    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);\n    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);\n    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);\n\n    var _this = {};\n\n    var getBCHDigit = function(data) {\n      var digit = 0;\n      while (data != 0) {\n        digit += 1;\n        data >>>= 1;\n      }\n      return digit;\n    };\n\n    _this.getBCHTypeInfo = function(data) {\n      var d = data << 10;\n      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );\n      }\n      return ( (data << 10) | d) ^ G15_MASK;\n    };\n\n    _this.getBCHTypeNumber = function(data) {\n      var d = data << 12;\n      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );\n      }\n      return (data << 12) | d;\n    };\n\n    _this.getPatternPosition = function(typeNumber) {\n      return PATTERN_POSITION_TABLE[typeNumber - 1];\n    };\n\n    _this.getMaskFunction = function(maskPattern) {\n\n      switch (maskPattern) {\n\n      case QRMaskPattern.PATTERN000 :\n        return function(i, j) { return (i + j) % 2 == 0; };\n      case QRMaskPattern.PATTERN001 :\n        return function(i, j) { return i % 2 == 0; };\n      case QRMaskPattern.PATTERN010 :\n        return function(i, j) { return j % 3 == 0; };\n      case QRMaskPattern.PATTERN011 :\n        return function(i, j) { return (i + j) % 3 == 0; };\n      case QRMaskPattern.PATTERN100 :\n        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };\n      case QRMaskPattern.PATTERN101 :\n        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };\n      case QRMaskPattern.PATTERN110 :\n        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };\n      case QRMaskPattern.PATTERN111 :\n        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };\n\n      default :\n        throw 'bad maskPattern:' + maskPattern;\n      }\n    };\n\n    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {\n      var a = qrPolynomial([1], 0);\n      for (var i = 0; i < errorCorrectLength; i += 1) {\n        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );\n      }\n      return a;\n    };\n\n    _this.getLengthInBits = function(mode, type) {\n\n      if (1 <= type && type < 10) {\n\n        // 1 - 9\n\n        switch(mode) {\n        case QRMode.MODE_NUMBER    : return 10;\n        case QRMode.MODE_ALPHA_NUM : return 9;\n        case QRMode.MODE_8BIT_BYTE : return 8;\n        case QRMode.MODE_KANJI     : return 8;\n        default :\n          throw 'mode:' + mode;\n        }\n\n      } else if (type < 27) {\n\n        // 10 - 26\n\n        switch(mode) {\n        case QRMode.MODE_NUMBER    : return 12;\n        case QRMode.MODE_ALPHA_NUM : return 11;\n        case QRMode.MODE_8BIT_BYTE : return 16;\n        case QRMode.MODE_KANJI     : return 10;\n        default :\n          throw 'mode:' + mode;\n        }\n\n      } else if (type < 41) {\n\n        // 27 - 40\n\n        switch(mode) {\n        case QRMode.MODE_NUMBER    : return 14;\n        case QRMode.MODE_ALPHA_NUM : return 13;\n        case QRMode.MODE_8BIT_BYTE : return 16;\n        case QRMode.MODE_KANJI     : return 12;\n        default :\n          throw 'mode:' + mode;\n        }\n\n      } else {\n        throw 'type:' + type;\n      }\n    };\n\n    _this.getLostPoint = function(qrcode) {\n\n      var moduleCount = qrcode.getModuleCount();\n\n      var lostPoint = 0;\n\n      // LEVEL1\n\n      for (var row = 0; row < moduleCount; row += 1) {\n        for (var col = 0; col < moduleCount; col += 1) {\n\n          var sameCount = 0;\n          var dark = qrcode.isDark(row, col);\n\n          for (var r = -1; r <= 1; r += 1) {\n\n            if (row + r < 0 || moduleCount <= row + r) {\n              continue;\n            }\n\n            for (var c = -1; c <= 1; c += 1) {\n\n              if (col + c < 0 || moduleCount <= col + c) {\n                continue;\n              }\n\n              if (r == 0 && c == 0) {\n                continue;\n              }\n\n              if (dark == qrcode.isDark(row + r, col + c) ) {\n                sameCount += 1;\n              }\n            }\n          }\n\n          if (sameCount > 5) {\n            lostPoint += (3 + sameCount - 5);\n          }\n        }\n      };\n\n      // LEVEL2\n\n      for (var row = 0; row < moduleCount - 1; row += 1) {\n        for (var col = 0; col < moduleCount - 1; col += 1) {\n          var count = 0;\n          if (qrcode.isDark(row, col) ) count += 1;\n          if (qrcode.isDark(row + 1, col) ) count += 1;\n          if (qrcode.isDark(row, col + 1) ) count += 1;\n          if (qrcode.isDark(row + 1, col + 1) ) count += 1;\n          if (count == 0 || count == 4) {\n            lostPoint += 3;\n          }\n        }\n      }\n\n      // LEVEL3\n\n      for (var row = 0; row < moduleCount; row += 1) {\n        for (var col = 0; col < moduleCount - 6; col += 1) {\n          if (qrcode.isDark(row, col)\n              && !qrcode.isDark(row, col + 1)\n              &&  qrcode.isDark(row, col + 2)\n              &&  qrcode.isDark(row, col + 3)\n              &&  qrcode.isDark(row, col + 4)\n              && !qrcode.isDark(row, col + 5)\n              &&  qrcode.isDark(row, col + 6) ) {\n            lostPoint += 40;\n          }\n        }\n      }\n\n      for (var col = 0; col < moduleCount; col += 1) {\n        for (var row = 0; row < moduleCount - 6; row += 1) {\n          if (qrcode.isDark(row, col)\n              && !qrcode.isDark(row + 1, col)\n              &&  qrcode.isDark(row + 2, col)\n              &&  qrcode.isDark(row + 3, col)\n              &&  qrcode.isDark(row + 4, col)\n              && !qrcode.isDark(row + 5, col)\n              &&  qrcode.isDark(row + 6, col) ) {\n            lostPoint += 40;\n          }\n        }\n      }\n\n      // LEVEL4\n\n      var darkCount = 0;\n\n      for (var col = 0; col < moduleCount; col += 1) {\n        for (var row = 0; row < moduleCount; row += 1) {\n          if (qrcode.isDark(row, col) ) {\n            darkCount += 1;\n          }\n        }\n      }\n\n      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n      lostPoint += ratio * 10;\n\n      return lostPoint;\n    };\n\n    return _this;\n  }();\n\n  //---------------------------------------------------------------------\n  // QRMath\n  //---------------------------------------------------------------------\n\n  var QRMath = function() {\n\n    var EXP_TABLE = new Array(256);\n    var LOG_TABLE = new Array(256);\n\n    // initialize tables\n    for (var i = 0; i < 8; i += 1) {\n      EXP_TABLE[i] = 1 << i;\n    }\n    for (var i = 8; i < 256; i += 1) {\n      EXP_TABLE[i] = EXP_TABLE[i - 4]\n        ^ EXP_TABLE[i - 5]\n        ^ EXP_TABLE[i - 6]\n        ^ EXP_TABLE[i - 8];\n    }\n    for (var i = 0; i < 255; i += 1) {\n      LOG_TABLE[EXP_TABLE[i] ] = i;\n    }\n\n    var _this = {};\n\n    _this.glog = function(n) {\n\n      if (n < 1) {\n        throw 'glog(' + n + ')';\n      }\n\n      return LOG_TABLE[n];\n    };\n\n    _this.gexp = function(n) {\n\n      while (n < 0) {\n        n += 255;\n      }\n\n      while (n >= 256) {\n        n -= 255;\n      }\n\n      return EXP_TABLE[n];\n    };\n\n    return _this;\n  }();\n\n  //---------------------------------------------------------------------\n  // qrPolynomial\n  //---------------------------------------------------------------------\n\n  function qrPolynomial(num, shift) {\n\n    if (typeof num.length == 'undefined') {\n      throw num.length + '/' + shift;\n    }\n\n    var _num = function() {\n      var offset = 0;\n      while (offset < num.length && num[offset] == 0) {\n        offset += 1;\n      }\n      var _num = new Array(num.length - offset + shift);\n      for (var i = 0; i < num.length - offset; i += 1) {\n        _num[i] = num[i + offset];\n      }\n      return _num;\n    }();\n\n    var _this = {};\n\n    _this.getAt = function(index) {\n      return _num[index];\n    };\n\n    _this.getLength = function() {\n      return _num.length;\n    };\n\n    _this.multiply = function(e) {\n\n      var num = new Array(_this.getLength() + e.getLength() - 1);\n\n      for (var i = 0; i < _this.getLength(); i += 1) {\n        for (var j = 0; j < e.getLength(); j += 1) {\n          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );\n        }\n      }\n\n      return qrPolynomial(num, 0);\n    };\n\n    _this.mod = function(e) {\n\n      if (_this.getLength() - e.getLength() < 0) {\n        return _this;\n      }\n\n      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );\n\n      var num = new Array(_this.getLength() );\n      for (var i = 0; i < _this.getLength(); i += 1) {\n        num[i] = _this.getAt(i);\n      }\n\n      for (var i = 0; i < e.getLength(); i += 1) {\n        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);\n      }\n\n      // recursive call\n      return qrPolynomial(num, 0).mod(e);\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // QRRSBlock\n  //---------------------------------------------------------------------\n\n  var QRRSBlock = function() {\n\n    var RS_BLOCK_TABLE = [\n\n      // L\n      // M\n      // Q\n      // H\n\n      // 1\n      [1, 26, 19],\n      [1, 26, 16],\n      [1, 26, 13],\n      [1, 26, 9],\n\n      // 2\n      [1, 44, 34],\n      [1, 44, 28],\n      [1, 44, 22],\n      [1, 44, 16],\n\n      // 3\n      [1, 70, 55],\n      [1, 70, 44],\n      [2, 35, 17],\n      [2, 35, 13],\n\n      // 4\n      [1, 100, 80],\n      [2, 50, 32],\n      [2, 50, 24],\n      [4, 25, 9],\n\n      // 5\n      [1, 134, 108],\n      [2, 67, 43],\n      [2, 33, 15, 2, 34, 16],\n      [2, 33, 11, 2, 34, 12],\n\n      // 6\n      [2, 86, 68],\n      [4, 43, 27],\n      [4, 43, 19],\n      [4, 43, 15],\n\n      // 7\n      [2, 98, 78],\n      [4, 49, 31],\n      [2, 32, 14, 4, 33, 15],\n      [4, 39, 13, 1, 40, 14],\n\n      // 8\n      [2, 121, 97],\n      [2, 60, 38, 2, 61, 39],\n      [4, 40, 18, 2, 41, 19],\n      [4, 40, 14, 2, 41, 15],\n\n      // 9\n      [2, 146, 116],\n      [3, 58, 36, 2, 59, 37],\n      [4, 36, 16, 4, 37, 17],\n      [4, 36, 12, 4, 37, 13],\n\n      // 10\n      [2, 86, 68, 2, 87, 69],\n      [4, 69, 43, 1, 70, 44],\n      [6, 43, 19, 2, 44, 20],\n      [6, 43, 15, 2, 44, 16],\n\n      // 11\n      [4, 101, 81],\n      [1, 80, 50, 4, 81, 51],\n      [4, 50, 22, 4, 51, 23],\n      [3, 36, 12, 8, 37, 13],\n\n      // 12\n      [2, 116, 92, 2, 117, 93],\n      [6, 58, 36, 2, 59, 37],\n      [4, 46, 20, 6, 47, 21],\n      [7, 42, 14, 4, 43, 15],\n\n      // 13\n      [4, 133, 107],\n      [8, 59, 37, 1, 60, 38],\n      [8, 44, 20, 4, 45, 21],\n      [12, 33, 11, 4, 34, 12],\n\n      // 14\n      [3, 145, 115, 1, 146, 116],\n      [4, 64, 40, 5, 65, 41],\n      [11, 36, 16, 5, 37, 17],\n      [11, 36, 12, 5, 37, 13],\n\n      // 15\n      [5, 109, 87, 1, 110, 88],\n      [5, 65, 41, 5, 66, 42],\n      [5, 54, 24, 7, 55, 25],\n      [11, 36, 12, 7, 37, 13],\n\n      // 16\n      [5, 122, 98, 1, 123, 99],\n      [7, 73, 45, 3, 74, 46],\n      [15, 43, 19, 2, 44, 20],\n      [3, 45, 15, 13, 46, 16],\n\n      // 17\n      [1, 135, 107, 5, 136, 108],\n      [10, 74, 46, 1, 75, 47],\n      [1, 50, 22, 15, 51, 23],\n      [2, 42, 14, 17, 43, 15],\n\n      // 18\n      [5, 150, 120, 1, 151, 121],\n      [9, 69, 43, 4, 70, 44],\n      [17, 50, 22, 1, 51, 23],\n      [2, 42, 14, 19, 43, 15],\n\n      // 19\n      [3, 141, 113, 4, 142, 114],\n      [3, 70, 44, 11, 71, 45],\n      [17, 47, 21, 4, 48, 22],\n      [9, 39, 13, 16, 40, 14],\n\n      // 20\n      [3, 135, 107, 5, 136, 108],\n      [3, 67, 41, 13, 68, 42],\n      [15, 54, 24, 5, 55, 25],\n      [15, 43, 15, 10, 44, 16],\n\n      // 21\n      [4, 144, 116, 4, 145, 117],\n      [17, 68, 42],\n      [17, 50, 22, 6, 51, 23],\n      [19, 46, 16, 6, 47, 17],\n\n      // 22\n      [2, 139, 111, 7, 140, 112],\n      [17, 74, 46],\n      [7, 54, 24, 16, 55, 25],\n      [34, 37, 13],\n\n      // 23\n      [4, 151, 121, 5, 152, 122],\n      [4, 75, 47, 14, 76, 48],\n      [11, 54, 24, 14, 55, 25],\n      [16, 45, 15, 14, 46, 16],\n\n      // 24\n      [6, 147, 117, 4, 148, 118],\n      [6, 73, 45, 14, 74, 46],\n      [11, 54, 24, 16, 55, 25],\n      [30, 46, 16, 2, 47, 17],\n\n      // 25\n      [8, 132, 106, 4, 133, 107],\n      [8, 75, 47, 13, 76, 48],\n      [7, 54, 24, 22, 55, 25],\n      [22, 45, 15, 13, 46, 16],\n\n      // 26\n      [10, 142, 114, 2, 143, 115],\n      [19, 74, 46, 4, 75, 47],\n      [28, 50, 22, 6, 51, 23],\n      [33, 46, 16, 4, 47, 17],\n\n      // 27\n      [8, 152, 122, 4, 153, 123],\n      [22, 73, 45, 3, 74, 46],\n      [8, 53, 23, 26, 54, 24],\n      [12, 45, 15, 28, 46, 16],\n\n      // 28\n      [3, 147, 117, 10, 148, 118],\n      [3, 73, 45, 23, 74, 46],\n      [4, 54, 24, 31, 55, 25],\n      [11, 45, 15, 31, 46, 16],\n\n      // 29\n      [7, 146, 116, 7, 147, 117],\n      [21, 73, 45, 7, 74, 46],\n      [1, 53, 23, 37, 54, 24],\n      [19, 45, 15, 26, 46, 16],\n\n      // 30\n      [5, 145, 115, 10, 146, 116],\n      [19, 75, 47, 10, 76, 48],\n      [15, 54, 24, 25, 55, 25],\n      [23, 45, 15, 25, 46, 16],\n\n      // 31\n      [13, 145, 115, 3, 146, 116],\n      [2, 74, 46, 29, 75, 47],\n      [42, 54, 24, 1, 55, 25],\n      [23, 45, 15, 28, 46, 16],\n\n      // 32\n      [17, 145, 115],\n      [10, 74, 46, 23, 75, 47],\n      [10, 54, 24, 35, 55, 25],\n      [19, 45, 15, 35, 46, 16],\n\n      // 33\n      [17, 145, 115, 1, 146, 116],\n      [14, 74, 46, 21, 75, 47],\n      [29, 54, 24, 19, 55, 25],\n      [11, 45, 15, 46, 46, 16],\n\n      // 34\n      [13, 145, 115, 6, 146, 116],\n      [14, 74, 46, 23, 75, 47],\n      [44, 54, 24, 7, 55, 25],\n      [59, 46, 16, 1, 47, 17],\n\n      // 35\n      [12, 151, 121, 7, 152, 122],\n      [12, 75, 47, 26, 76, 48],\n      [39, 54, 24, 14, 55, 25],\n      [22, 45, 15, 41, 46, 16],\n\n      // 36\n      [6, 151, 121, 14, 152, 122],\n      [6, 75, 47, 34, 76, 48],\n      [46, 54, 24, 10, 55, 25],\n      [2, 45, 15, 64, 46, 16],\n\n      // 37\n      [17, 152, 122, 4, 153, 123],\n      [29, 74, 46, 14, 75, 47],\n      [49, 54, 24, 10, 55, 25],\n      [24, 45, 15, 46, 46, 16],\n\n      // 38\n      [4, 152, 122, 18, 153, 123],\n      [13, 74, 46, 32, 75, 47],\n      [48, 54, 24, 14, 55, 25],\n      [42, 45, 15, 32, 46, 16],\n\n      // 39\n      [20, 147, 117, 4, 148, 118],\n      [40, 75, 47, 7, 76, 48],\n      [43, 54, 24, 22, 55, 25],\n      [10, 45, 15, 67, 46, 16],\n\n      // 40\n      [19, 148, 118, 6, 149, 119],\n      [18, 75, 47, 31, 76, 48],\n      [34, 54, 24, 34, 55, 25],\n      [20, 45, 15, 61, 46, 16]\n    ];\n\n    var qrRSBlock = function(totalCount, dataCount) {\n      var _this = {};\n      _this.totalCount = totalCount;\n      _this.dataCount = dataCount;\n      return _this;\n    };\n\n    var _this = {};\n\n    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {\n\n      switch(errorCorrectionLevel) {\n      case QRErrorCorrectionLevel.L :\n        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n      case QRErrorCorrectionLevel.M :\n        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n      case QRErrorCorrectionLevel.Q :\n        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n      case QRErrorCorrectionLevel.H :\n        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n      default :\n        return undefined;\n      }\n    };\n\n    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {\n\n      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);\n\n      if (typeof rsBlock == 'undefined') {\n        throw 'bad rs block @ typeNumber:' + typeNumber +\n            '/errorCorrectionLevel:' + errorCorrectionLevel;\n      }\n\n      var length = rsBlock.length / 3;\n\n      var list = [];\n\n      for (var i = 0; i < length; i += 1) {\n\n        var count = rsBlock[i * 3 + 0];\n        var totalCount = rsBlock[i * 3 + 1];\n        var dataCount = rsBlock[i * 3 + 2];\n\n        for (var j = 0; j < count; j += 1) {\n          list.push(qrRSBlock(totalCount, dataCount) );\n        }\n      }\n\n      return list;\n    };\n\n    return _this;\n  }();\n\n  //---------------------------------------------------------------------\n  // qrBitBuffer\n  //---------------------------------------------------------------------\n\n  var qrBitBuffer = function() {\n\n    var _buffer = [];\n    var _length = 0;\n\n    var _this = {};\n\n    _this.getBuffer = function() {\n      return _buffer;\n    };\n\n    _this.getAt = function(index) {\n      var bufIndex = Math.floor(index / 8);\n      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;\n    };\n\n    _this.put = function(num, length) {\n      for (var i = 0; i < length; i += 1) {\n        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);\n      }\n    };\n\n    _this.getLengthInBits = function() {\n      return _length;\n    };\n\n    _this.putBit = function(bit) {\n\n      var bufIndex = Math.floor(_length / 8);\n      if (_buffer.length <= bufIndex) {\n        _buffer.push(0);\n      }\n\n      if (bit) {\n        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );\n      }\n\n      _length += 1;\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // qrNumber\n  //---------------------------------------------------------------------\n\n  var qrNumber = function(data) {\n\n    var _mode = QRMode.MODE_NUMBER;\n    var _data = data;\n\n    var _this = {};\n\n    _this.getMode = function() {\n      return _mode;\n    };\n\n    _this.getLength = function(buffer) {\n      return _data.length;\n    };\n\n    _this.write = function(buffer) {\n\n      var data = _data;\n\n      var i = 0;\n\n      while (i + 2 < data.length) {\n        buffer.put(strToNum(data.substring(i, i + 3) ), 10);\n        i += 3;\n      }\n\n      if (i < data.length) {\n        if (data.length - i == 1) {\n          buffer.put(strToNum(data.substring(i, i + 1) ), 4);\n        } else if (data.length - i == 2) {\n          buffer.put(strToNum(data.substring(i, i + 2) ), 7);\n        }\n      }\n    };\n\n    var strToNum = function(s) {\n      var num = 0;\n      for (var i = 0; i < s.length; i += 1) {\n        num = num * 10 + chatToNum(s.charAt(i) );\n      }\n      return num;\n    };\n\n    var chatToNum = function(c) {\n      if ('0' <= c && c <= '9') {\n        return c.charCodeAt(0) - '0'.charCodeAt(0);\n      }\n      throw 'illegal char :' + c;\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // qrAlphaNum\n  //---------------------------------------------------------------------\n\n  var qrAlphaNum = function(data) {\n\n    var _mode = QRMode.MODE_ALPHA_NUM;\n    var _data = data;\n\n    var _this = {};\n\n    _this.getMode = function() {\n      return _mode;\n    };\n\n    _this.getLength = function(buffer) {\n      return _data.length;\n    };\n\n    _this.write = function(buffer) {\n\n      var s = _data;\n\n      var i = 0;\n\n      while (i + 1 < s.length) {\n        buffer.put(\n          getCode(s.charAt(i) ) * 45 +\n          getCode(s.charAt(i + 1) ), 11);\n        i += 2;\n      }\n\n      if (i < s.length) {\n        buffer.put(getCode(s.charAt(i) ), 6);\n      }\n    };\n\n    var getCode = function(c) {\n\n      if ('0' <= c && c <= '9') {\n        return c.charCodeAt(0) - '0'.charCodeAt(0);\n      } else if ('A' <= c && c <= 'Z') {\n        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;\n      } else {\n        switch (c) {\n        case ' ' : return 36;\n        case '$' : return 37;\n        case '%' : return 38;\n        case '*' : return 39;\n        case '+' : return 40;\n        case '-' : return 41;\n        case '.' : return 42;\n        case '/' : return 43;\n        case ':' : return 44;\n        default :\n          throw 'illegal char :' + c;\n        }\n      }\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // qr8BitByte\n  //---------------------------------------------------------------------\n\n  var qr8BitByte = function(data) {\n\n    var _mode = QRMode.MODE_8BIT_BYTE;\n    var _data = data;\n    var _bytes = qrcode.stringToBytes(data);\n\n    var _this = {};\n\n    _this.getMode = function() {\n      return _mode;\n    };\n\n    _this.getLength = function(buffer) {\n      return _bytes.length;\n    };\n\n    _this.write = function(buffer) {\n      for (var i = 0; i < _bytes.length; i += 1) {\n        buffer.put(_bytes[i], 8);\n      }\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // qrKanji\n  //---------------------------------------------------------------------\n\n  var qrKanji = function(data) {\n\n    var _mode = QRMode.MODE_KANJI;\n    var _data = data;\n\n    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];\n    if (!stringToBytes) {\n      throw 'sjis not supported.';\n    }\n    !function(c, code) {\n      // self test for sjis support.\n      var test = stringToBytes(c);\n      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {\n        throw 'sjis not supported.';\n      }\n    }('\\u53cb', 0x9746);\n\n    var _bytes = stringToBytes(data);\n\n    var _this = {};\n\n    _this.getMode = function() {\n      return _mode;\n    };\n\n    _this.getLength = function(buffer) {\n      return ~~(_bytes.length / 2);\n    };\n\n    _this.write = function(buffer) {\n\n      var data = _bytes;\n\n      var i = 0;\n\n      while (i + 1 < data.length) {\n\n        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);\n\n        if (0x8140 <= c && c <= 0x9FFC) {\n          c -= 0x8140;\n        } else if (0xE040 <= c && c <= 0xEBBF) {\n          c -= 0xC140;\n        } else {\n          throw 'illegal char at ' + (i + 1) + '/' + c;\n        }\n\n        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);\n\n        buffer.put(c, 13);\n\n        i += 2;\n      }\n\n      if (i < data.length) {\n        throw 'illegal char at ' + (i + 1);\n      }\n    };\n\n    return _this;\n  };\n\n  //=====================================================================\n  // GIF Support etc.\n  //\n\n  //---------------------------------------------------------------------\n  // byteArrayOutputStream\n  //---------------------------------------------------------------------\n\n  var byteArrayOutputStream = function() {\n\n    var _bytes = [];\n\n    var _this = {};\n\n    _this.writeByte = function(b) {\n      _bytes.push(b & 0xff);\n    };\n\n    _this.writeShort = function(i) {\n      _this.writeByte(i);\n      _this.writeByte(i >>> 8);\n    };\n\n    _this.writeBytes = function(b, off, len) {\n      off = off || 0;\n      len = len || b.length;\n      for (var i = 0; i < len; i += 1) {\n        _this.writeByte(b[i + off]);\n      }\n    };\n\n    _this.writeString = function(s) {\n      for (var i = 0; i < s.length; i += 1) {\n        _this.writeByte(s.charCodeAt(i) );\n      }\n    };\n\n    _this.toByteArray = function() {\n      return _bytes;\n    };\n\n    _this.toString = function() {\n      var s = '';\n      s += '[';\n      for (var i = 0; i < _bytes.length; i += 1) {\n        if (i > 0) {\n          s += ',';\n        }\n        s += _bytes[i];\n      }\n      s += ']';\n      return s;\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // base64EncodeOutputStream\n  //---------------------------------------------------------------------\n\n  var base64EncodeOutputStream = function() {\n\n    var _buffer = 0;\n    var _buflen = 0;\n    var _length = 0;\n    var _base64 = '';\n\n    var _this = {};\n\n    var writeEncoded = function(b) {\n      _base64 += String.fromCharCode(encode(b & 0x3f) );\n    };\n\n    var encode = function(n) {\n      if (n < 0) {\n        // error.\n      } else if (n < 26) {\n        return 0x41 + n;\n      } else if (n < 52) {\n        return 0x61 + (n - 26);\n      } else if (n < 62) {\n        return 0x30 + (n - 52);\n      } else if (n == 62) {\n        return 0x2b;\n      } else if (n == 63) {\n        return 0x2f;\n      }\n      throw 'n:' + n;\n    };\n\n    _this.writeByte = function(n) {\n\n      _buffer = (_buffer << 8) | (n & 0xff);\n      _buflen += 8;\n      _length += 1;\n\n      while (_buflen >= 6) {\n        writeEncoded(_buffer >>> (_buflen - 6) );\n        _buflen -= 6;\n      }\n    };\n\n    _this.flush = function() {\n\n      if (_buflen > 0) {\n        writeEncoded(_buffer << (6 - _buflen) );\n        _buffer = 0;\n        _buflen = 0;\n      }\n\n      if (_length % 3 != 0) {\n        // padding\n        var padlen = 3 - _length % 3;\n        for (var i = 0; i < padlen; i += 1) {\n          _base64 += '=';\n        }\n      }\n    };\n\n    _this.toString = function() {\n      return _base64;\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // base64DecodeInputStream\n  //---------------------------------------------------------------------\n\n  var base64DecodeInputStream = function(str) {\n\n    var _str = str;\n    var _pos = 0;\n    var _buffer = 0;\n    var _buflen = 0;\n\n    var _this = {};\n\n    _this.read = function() {\n\n      while (_buflen < 8) {\n\n        if (_pos >= _str.length) {\n          if (_buflen == 0) {\n            return -1;\n          }\n          throw 'unexpected end of file./' + _buflen;\n        }\n\n        var c = _str.charAt(_pos);\n        _pos += 1;\n\n        if (c == '=') {\n          _buflen = 0;\n          return -1;\n        } else if (c.match(/^\\s$/) ) {\n          // ignore if whitespace.\n          continue;\n        }\n\n        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );\n        _buflen += 6;\n      }\n\n      var n = (_buffer >>> (_buflen - 8) ) & 0xff;\n      _buflen -= 8;\n      return n;\n    };\n\n    var decode = function(c) {\n      if (0x41 <= c && c <= 0x5a) {\n        return c - 0x41;\n      } else if (0x61 <= c && c <= 0x7a) {\n        return c - 0x61 + 26;\n      } else if (0x30 <= c && c <= 0x39) {\n        return c - 0x30 + 52;\n      } else if (c == 0x2b) {\n        return 62;\n      } else if (c == 0x2f) {\n        return 63;\n      } else {\n        throw 'c:' + c;\n      }\n    };\n\n    return _this;\n  };\n\n  //---------------------------------------------------------------------\n  // gifImage (B/W)\n  //---------------------------------------------------------------------\n\n  var gifImage = function(width, height) {\n\n    var _width = width;\n    var _height = height;\n    var _data = new Array(width * height);\n\n    var _this = {};\n\n    _this.setPixel = function(x, y, pixel) {\n      _data[y * _width + x] = pixel;\n    };\n\n    _this.write = function(out) {\n\n      //---------------------------------\n      // GIF Signature\n\n      out.writeString('GIF87a');\n\n      //---------------------------------\n      // Screen Descriptor\n\n      out.writeShort(_width);\n      out.writeShort(_height);\n\n      out.writeByte(0x80); // 2bit\n      out.writeByte(0);\n      out.writeByte(0);\n\n      //---------------------------------\n      // Global Color Map\n\n      // black\n      out.writeByte(0x00);\n      out.writeByte(0x00);\n      out.writeByte(0x00);\n\n      // white\n      out.writeByte(0xff);\n      out.writeByte(0xff);\n      out.writeByte(0xff);\n\n      //---------------------------------\n      // Image Descriptor\n\n      out.writeString(',');\n      out.writeShort(0);\n      out.writeShort(0);\n      out.writeShort(_width);\n      out.writeShort(_height);\n      out.writeByte(0);\n\n      //---------------------------------\n      // Local Color Map\n\n      //---------------------------------\n      // Raster Data\n\n      var lzwMinCodeSize = 2;\n      var raster = getLZWRaster(lzwMinCodeSize);\n\n      out.writeByte(lzwMinCodeSize);\n\n      var offset = 0;\n\n      while (raster.length - offset > 255) {\n        out.writeByte(255);\n        out.writeBytes(raster, offset, 255);\n        offset += 255;\n      }\n\n      out.writeByte(raster.length - offset);\n      out.writeBytes(raster, offset, raster.length - offset);\n      out.writeByte(0x00);\n\n      //---------------------------------\n      // GIF Terminator\n      out.writeString(';');\n    };\n\n    var bitOutputStream = function(out) {\n\n      var _out = out;\n      var _bitLength = 0;\n      var _bitBuffer = 0;\n\n      var _this = {};\n\n      _this.write = function(data, length) {\n\n        if ( (data >>> length) != 0) {\n          throw 'length over';\n        }\n\n        while (_bitLength + length >= 8) {\n          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );\n          length -= (8 - _bitLength);\n          data >>>= (8 - _bitLength);\n          _bitBuffer = 0;\n          _bitLength = 0;\n        }\n\n        _bitBuffer = (data << _bitLength) | _bitBuffer;\n        _bitLength = _bitLength + length;\n      };\n\n      _this.flush = function() {\n        if (_bitLength > 0) {\n          _out.writeByte(_bitBuffer);\n        }\n      };\n\n      return _this;\n    };\n\n    var getLZWRaster = function(lzwMinCodeSize) {\n\n      var clearCode = 1 << lzwMinCodeSize;\n      var endCode = (1 << lzwMinCodeSize) + 1;\n      var bitLength = lzwMinCodeSize + 1;\n\n      // Setup LZWTable\n      var table = lzwTable();\n\n      for (var i = 0; i < clearCode; i += 1) {\n        table.add(String.fromCharCode(i) );\n      }\n      table.add(String.fromCharCode(clearCode) );\n      table.add(String.fromCharCode(endCode) );\n\n      var byteOut = byteArrayOutputStream();\n      var bitOut = bitOutputStream(byteOut);\n\n      // clear code\n      bitOut.write(clearCode, bitLength);\n\n      var dataIndex = 0;\n\n      var s = String.fromCharCode(_data[dataIndex]);\n      dataIndex += 1;\n\n      while (dataIndex < _data.length) {\n\n        var c = String.fromCharCode(_data[dataIndex]);\n        dataIndex += 1;\n\n        if (table.contains(s + c) ) {\n\n          s = s + c;\n\n        } else {\n\n          bitOut.write(table.indexOf(s), bitLength);\n\n          if (table.size() < 0xfff) {\n\n            if (table.size() == (1 << bitLength) ) {\n              bitLength += 1;\n            }\n\n            table.add(s + c);\n          }\n\n          s = c;\n        }\n      }\n\n      bitOut.write(table.indexOf(s), bitLength);\n\n      // end code\n      bitOut.write(endCode, bitLength);\n\n      bitOut.flush();\n\n      return byteOut.toByteArray();\n    };\n\n    var lzwTable = function() {\n\n      var _map = {};\n      var _size = 0;\n\n      var _this = {};\n\n      _this.add = function(key) {\n        if (_this.contains(key) ) {\n          throw 'dup key:' + key;\n        }\n        _map[key] = _size;\n        _size += 1;\n      };\n\n      _this.size = function() {\n        return _size;\n      };\n\n      _this.indexOf = function(key) {\n        return _map[key];\n      };\n\n      _this.contains = function(key) {\n        return typeof _map[key] != 'undefined';\n      };\n\n      return _this;\n    };\n\n    return _this;\n  };\n\n  var createDataURL = function(width, height, getPixel) {\n    var gif = gifImage(width, height);\n    for (var y = 0; y < height; y += 1) {\n      for (var x = 0; x < width; x += 1) {\n        gif.setPixel(x, y, getPixel(x, y) );\n      }\n    }\n\n    var b = byteArrayOutputStream();\n    gif.write(b);\n\n    var base64 = base64EncodeOutputStream();\n    var bytes = b.toByteArray();\n    for (var i = 0; i < bytes.length; i += 1) {\n      base64.writeByte(bytes[i]);\n    }\n    base64.flush();\n\n    return 'data:image/gif;base64,' + base64;\n  };\n\n  //---------------------------------------------------------------------\n  // returns qrcode function.\n\n  return qrcode;\n}();\n\n// multibyte support\n!function() {\n\n  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {\n    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n    function toUTF8Array(str) {\n      var utf8 = [];\n      for (var i=0; i < str.length; i++) {\n        var charcode = str.charCodeAt(i);\n        if (charcode < 0x80) utf8.push(charcode);\n        else if (charcode < 0x800) {\n          utf8.push(0xc0 | (charcode >> 6),\n              0x80 | (charcode & 0x3f));\n        }\n        else if (charcode < 0xd800 || charcode >= 0xe000) {\n          utf8.push(0xe0 | (charcode >> 12),\n              0x80 | ((charcode>>6) & 0x3f),\n              0x80 | (charcode & 0x3f));\n        }\n        // surrogate pair\n        else {\n          i++;\n          // UTF-16 encodes 0x10000-0x10FFFF by\n          // subtracting 0x10000 and splitting the\n          // 20 bits of 0x0-0xFFFFF into two halves\n          charcode = 0x10000 + (((charcode & 0x3ff)<<10)\n            | (str.charCodeAt(i) & 0x3ff));\n          utf8.push(0xf0 | (charcode >>18),\n              0x80 | ((charcode>>12) & 0x3f),\n              0x80 | ((charcode>>6) & 0x3f),\n              0x80 | (charcode & 0x3f));\n        }\n      }\n      return utf8;\n    }\n    return toUTF8Array(s);\n  };\n\n}();\n\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n      define([], factory);\n  } else if (typeof exports === 'object') {\n      module.exports = factory();\n  }\n}(function () {\n    return qrcode;\n}));\n","'use strict';\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\nrequire('inherits')(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\nvar Transform = require('./_stream_transform');\nrequire('inherits')(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/buffer_list');\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\nrequire('inherits')(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = require('./internal/streams/from');\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\nvar _require$codes = require('../errors').codes,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = require('./_stream_duplex');\nrequire('inherits')(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = require('./internal/streams/destroy');\nvar _require = require('./internal/streams/state'),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = require('../errors').codes,\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nrequire('inherits')(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};","'use strict';\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = require('./end-of-stream');\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;","'use strict';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require('buffer'),\n  Buffer = _require.Buffer;\nvar _require2 = require('util'),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();","'use strict';\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};","// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;","module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n","// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n'use strict';\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = require('../../../errors').codes,\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = require('./end-of-stream');\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;","'use strict';\n\nvar ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};","module.exports = require('events').EventEmitter;\n","/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/lib/_stream_readable.js');\nStream.Writable = require('readable-stream/lib/_stream_writable.js');\nStream.Duplex = require('readable-stream/lib/_stream_duplex.js');\nStream.Transform = require('readable-stream/lib/_stream_transform.js');\nStream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');\nStream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')\nStream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","/* (ignored) */","/* (ignored) */","/*passwordless-id/webauthn@2.1.2*/\nvar v=Object.defineProperty;var y=(e,t)=>{for(var a in t)v(e,a,{get:t[a],enumerable:!0})};var w={};y(w,{authenticate:()=>Y,isAutocompleteAvailable:()=>B,isAvailable:()=>H,isLocalAuthenticator:()=>V,register:()=>L});var u={};y(u,{bufferToHex:()=>C,concatenateBuffers:()=>O,isBase64url:()=>g,parseBase64url:()=>o,parseBuffer:()=>K,sha256:()=>A,toBase64url:()=>n,toBuffer:()=>f});function f(e){return Uint8Array.from(e,t=>t.charCodeAt(0)).buffer}function K(e){return String.fromCharCode(...new Uint8Array(e))}function g(e){return e.match(/^[a-zA-Z0-9\\-_]+=*$/)!==null}function n(e){return btoa(K(e)).replaceAll(\"+\",\"-\").replaceAll(\"/\",\"_\")}function o(e){return e=e.replaceAll(\"-\",\"+\").replaceAll(\"_\",\"/\"),f(atob(e))}async function A(e){return await crypto.subtle.digest(\"SHA-256\",e)}function C(e){return[...new Uint8Array(e)].map(t=>t.toString(16).padStart(2,\"0\")).join(\"\")}function O(e,t){var a=new Uint8Array(e.byteLength+t.byteLength);return a.set(new Uint8Array(e),0),a.set(new Uint8Array(t),e.byteLength),a}function H(){return!!window.PublicKeyCredential}async function V(){return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable()}function k(e){if(!(!e||e.length===0))return e.includes(\"client-device\")?e.includes(\"security-key\")||e.includes(\"hybrid\")?void 0:\"platform\":\"cross-platform\"}var s=null;async function L(e){if(!e.challenge)throw new Error('\"challenge\" required');if(!e.user)throw new Error('\"user\" required');if(!g(e.challenge))throw new Error(\"Provided challenge is not properly encoded in Base64url\");let t=typeof e.user==\"string\"?{name:e.user}:e.user;t.id||(t.id=crypto.randomUUID());let a={challenge:o(e.challenge),rp:{id:e.domain??window.location.hostname,name:e.domain??window.location.hostname},user:{id:f(t.id),name:t.name,displayName:t.displayName??t.name},hints:e.hints,pubKeyCredParams:[{alg:-7,type:\"public-key\"},{alg:-257,type:\"public-key\"}],timeout:e.timeout,authenticatorSelection:{userVerification:e.userVerification,authenticatorAttachment:k(e.hints),residentKey:e.discoverable??\"preferred\",requireResidentKey:e.discoverable===\"required\"},attestation:\"direct\"};console.debug(a),s?.abort(\"Cancel ongoing authentication\"),s=new AbortController;let r=await navigator.credentials.create({publicKey:a,signal:s?.signal}),i=r.response;if(s=null,console.debug(r),r.type!=\"public-key\")throw\"Unexpected credential type!\";let c=i.getPublicKey();if(!c)throw\"Non-compliant browser or authenticator!\";return{type:r.type,id:r.id,rawId:n(r.rawId),authenticatorAttachment:r.authenticatorAttachment,clientExtensionResults:r.getClientExtensionResults(),response:{attestationObject:n(i.attestationObject),authenticatorData:n(i.getAuthenticatorData()),clientDataJSON:n(i.clientDataJSON),publicKey:n(c),publicKeyAlgorithm:i.getPublicKeyAlgorithm(),transports:i.getTransports()},user:t}}async function B(){return PublicKeyCredential.isConditionalMediationAvailable&&PublicKeyCredential.isConditionalMediationAvailable()}async function Y(e){if(!g(e.challenge))throw new Error(\"Provided challenge is not properly encoded in Base64url\");if(e.autocomplete&&!await B())throw new Error(\"PAsskeys autocomplete with conditional mediation is not available in this browser.\");let t={challenge:o(e.challenge),rpId:e.domain??window.location.hostname,allowCredentials:e.allowCredentials?.map(M),hints:e.hints,userVerification:e.userVerification,timeout:e.timeout};console.debug(t),s?.abort(\"Cancel ongoing authentication\"),e.autocomplete&&(s=new AbortController);let a=await navigator.credentials.get({publicKey:t,mediation:e.autocomplete?\"conditional\":void 0,signal:s?.signal});if(a.type!=\"public-key\")throw\"Unexpected credential type!\";s=null,console.debug(a);let r=a.response;return{clientExtensionResults:a.getClientExtensionResults(),id:a.id,rawId:n(a.rawId),type:a.type,authenticatorAttachment:a.authenticatorAttachment,response:{authenticatorData:n(r.authenticatorData),clientDataJSON:n(r.clientDataJSON),signature:n(r.signature),userHandle:r.userHandle?n(r.userHandle):void 0}}}function M(e){return typeof e==\"string\"?{id:o(e),type:\"public-key\"}:{id:o(e.id),type:\"public-key\",transports:e.transports}}var F={};y(F,{parseCryptoKey:()=>R,randomChallenge:()=>J,verifyAuthentication:()=>q,verifyRegistration:()=>_,verifySignature:()=>U});var l={};y(l,{getAlgoName:()=>E,parseAuthentication:()=>j,parseAuthenticator:()=>b,parseClient:()=>S,parseRegistration:()=>z,toAuthenticationInfo:()=>I,toRegistrationInfo:()=>N});var p={\"00000000-0000-0000-0000-000000000000\":\"Unknown authenticator\",\"0076631b-d4a0-427f-5773-0ec71c9e0279\":\"HYPR FIDO2 Authenticator\",\"07a9f89c-6407-4594-9d56-621d5f1e358b\":\"NXP Semiconductros FIDO2 Conformance Testing CTAP2 Authenticator\",\"08987058-cadc-4b81-b6e1-30de50dcbe96\":\"Windows Hello\",\"092277e5-8437-46b5-b911-ea64b294acb7\":\"Taglio CTAP2.1 CS\",\"09591fc6-9811-48f7-8f57-b9f23df6413f\":\"Pone Biometrics OFFPAD Authenticator\",\"0acf3011-bc60-f375-fb53-6f05f43154e0\":\"Nymi FIDO2 Authenticator\",\"0bb43545-fd2c-4185-87dd-feb0b2916ace\":\"Security Key NFC by Yubico - Enterprise Edition\",\"0d9b2e56-566b-c393-2940-f821b7f15d6d\":\"Excelsecu eSecu FIDO2 Pro Security Key\",\"0ea242b4-43c4-4a1b-8b17-dd6d0b6baec6\":\"Keeper\",\"1105e4ed-af1d-02ff-ffff-ffffffffffff\":\"Egomet FIDO2 Authenticator for Android\",\"12ded745-4bed-47d4-abaa-e713f51d6393\":\"Feitian AllinOne FIDO2 Authenticator\",\"149a2021-8ef6-4133-96b8-81f8d5b7f1f5\":\"Security Key by Yubico with NFC\",\"17290f1e-c212-34d0-1423-365d729f09d9\":\"Thales PIN iOS SDK\",\"175cd298-83d2-4a26-b637-313c07a6434e\":\"Chunghwa Telecom FIDO2 Smart Card Authenticator\",\"19083c3d-8383-4b18-bc03-8f1c9ab2fd1b\":\"YubiKey 5 Series\",\"1c086528-58d5-f211-823c-356786e36140\":\"Atos CardOS FIDO2\",\"20f0be98-9af9-986a-4b42-8eca4acb28e4\":\"Excelsecu eSecu FIDO2 Fingerprint Security Key\",\"2194b428-9397-4046-8f39-007a1605a482\":\"IDPrime 931 Fido\",\"234cd403-35a2-4cc2-8015-77ea280c77f5\":\"Feitian ePass FIDO2-NFC Series (CTAP2.1, CTAP2.0, U2F)\",\"23786452-f02d-4344-87ed-aaf703726881\":\"SafeNet eToken Fusion CC\",\"2772ce93-eb4b-4090-8b73-330f48477d73\":\"Security Key NFC by Yubico - Enterprise Edition Preview\",\"2c0df832-92de-4be1-8412-88a8f074df4a\":\"Feitian FIDO Smart Card\",\"2d3bec26-15ee-4f5d-88b2-53622490270b\":\"HID Crescendo Key V2\",\"2fc0579f-8113-47ea-b116-bb5a8db9202a\":\"YubiKey 5 Series with NFC\",\"2ffd6452-01da-471f-821b-ea4bf6c8676a\":\"IDPrime 941 Fido\",\"30b5035e-d297-4fc1-b00b-addc96ba6a97\":\"OneSpan FIDO Touch\",\"30b5035e-d297-4ff1-b00b-addc96ba6a98\":\"OneSpan DIGIPASS FX1 BIO\",\"3124e301-f14e-4e38-876d-fbeeb090e7bf\":\"YubiKey 5 Series with Lightning Preview\",\"31c3f7ff-bf15-4327-83ec-9336abcbcd34\":\"WinMagic FIDO Eazy - Software\",\"341e4da9-3c2e-8103-5a9f-aad887135200\":\"Ledger Nano S FIDO2 Authenticator\",\"34f5766d-1536-4a24-9033-0e294e510fb0\":\"YubiKey 5 Series with NFC Preview\",\"361a3082-0278-4583-a16f-72a527f973e4\":\"eWBM eFA500 FIDO2 Authenticator\",\"3789da91-f943-46bc-95c3-50ea2012f03a\":\"NEOWAVE Winkeo FIDO2\",\"39a5647e-1853-446c-a1f6-a79bae9f5bc7\":\"IDmelon\",\"3b1adb99-0dfe-46fd-90b8-7f7614a4de2a\":\"GoTrust Idem Key FIDO2 Authenticator\",\"3e078ffd-4c54-4586-8baa-a77da113aec5\":\"Hideez Key 3 FIDO2\",\"3e22415d-7fdf-4ea4-8a0c-dd60c4249b9d\":\"Feitian iePass FIDO Authenticator\",\"3f59672f-20aa-4afe-b6f4-7e5e916b6d98\":\"Arculus FIDO 2.1 Key Card [P71]\",\"42b4fb4a-2866-43b2-9bf7-6c6669c2e5d3\":\"Google Titan Security Key v2\",\"454e5346-4944-4ffd-6c93-8e9267193e9a\":\"Ensurity ThinC\",\"454e5346-4944-4ffd-6c93-8e9267193e9b\":\"Ensurity AUTH BioPro\",\"47ab2fb4-66ac-4184-9ae1-86be814012d5\":\"Security Key NFC by Yubico - Enterprise Edition\",\"4b3f8944-d4f2-4d21-bb19-764a986ec160\":\"KeyXentic FIDO2 Secp256R1 FIDO2 CTAP2 Authenticator\",\"4c0cf95d-2f40-43b5-ba42-4c83a11c04ba\":\"Feitian BioPass FIDO2 Pro Authenticator\",\"4c50ff10-1057-4fc6-b8ed-43a529530c3c\":\"ImproveID Authenticator\",\"4d41190c-7beb-4a84-8018-adf265a6352d\":\"Thales IDPrime FIDO Bio\",\"4e768f2c-5fab-48b3-b300-220eb487752b\":\"Hideez Key 4 FIDO2 SDK\",\"504d7149-4e4c-3841-4555-55445a677357\":\"WiSECURE AuthTron USB FIDO2 Authenticator\",\"50726f74-6f6e-5061-7373-50726f746f6e\":\"Proton Pass\",\"50a45b0c-80e7-f944-bf29-f552bfa2e048\":\"ACS FIDO Authenticator\",\"516d3969-5a57-5651-5958-4e7a49434167\":\"SmartDisplayer BobeePass FIDO2 Authenticator\",\"531126d6-e717-415c-9320-3d9aa6981239\":\"Dashlane\",\"53414d53-554e-4700-0000-000000000000\":\"Samsung Pass\",\"5343502d-5343-5343-6172-644649444f32\":\"ESS Smart Card Inc. Authenticator\",\"54d9fee8-e621-4291-8b18-7157b99c5bec\":\"HID Crescendo Enabled\",\"5626bed4-e756-430b-a7ff-ca78c8b12738\":\"VALMIDO PRO FIDO\",\"58b44d0b-0a7c-f33a-fd48-f7153c871352\":\"Ledger Nano S Plus FIDO2 Authenticator\",\"5b0e46ba-db02-44ac-b979-ca9b84f5e335\":\"YubiKey 5 FIPS Series with Lightning Preview\",\"5ca1ab1e-1337-fa57-f1d0-a117e71ca702\":\"Allthenticator App: roaming BLE FIDO2 Allthenticator for Windows, Mac, Linux, and Allthenticate door readers\",\"5d629218-d3a5-11ed-afa1-0242ac120002\":\"Swissbit iShield Key Pro\",\"5fdb81b8-53f0-4967-a881-f5ec26fe4d18\":\"VinCSS FIDO2 Authenticator\",\"6002f033-3c07-ce3e-d0f7-0ffe5ed42543\":\"Excelsecu eSecu FIDO2 Fingerprint Key\",\"6028b017-b1d4-4c02-b4b3-afcdafc96bb2\":\"Windows Hello\",\"61250591-b2bc-4456-b719-0b17be90bb30\":\"eWBM eFPA FIDO2 Authenticator\",\"62e54e98-c209-4df3-b692-de71bb6a8528\":\"YubiKey 5 FIPS Series with NFC Preview\",\"664d9f67-84a2-412a-9ff7-b4f7d8ee6d05\":\"OpenSK authenticator\",\"66a0ccb3-bd6a-191f-ee06-e375c50b9846\":\"Thales Bio iOS SDK\",\"692db549-7ae5-44d5-a1e5-dd20a493b723\":\"HID Crescendo Key\",\"69700f79-d1fb-472e-bd9b-a3a3b9a9eda0\":\"Pone Biometrics OFFPAD Authenticator\",\"6d44ba9b-f6ec-2e49-b930-0c8fe920cb73\":\"Security Key by Yubico with NFC\",\"6dae43be-af9c-417b-8b9f-1b611168ec60\":\"Dapple Authenticator from Dapple Security Inc.\",\"73402251-f2a8-4f03-873e-3cb6db604b03\":\"uTrust FIDO2 Security Key\",\"73bb0cd4-e502-49b8-9c6f-b59445bf720b\":\"YubiKey 5 FIPS Series\",\"74820b05-a6c9-40f9-8fb0-9f86aca93998\":\"SafeNet eToken Fusion\",\"760eda36-00aa-4d29-855b-4012a182cdeb\":\"Security Key NFC by Yubico Preview\",\"77010bd7-212a-4fc9-b236-d2ca5e9d4084\":\"Feitian BioPass FIDO2 Authenticator\",\"771b48fd-d3d4-4f74-9232-fc157ab0507a\":\"Edge on Mac\",\"7d1351a6-e097-4852-b8bf-c9ac5c9ce4a3\":\"YubiKey Bio Series - Multi-protocol Edition\",\"7d2afadd-bf6b-44a2-a66b-e831fceb8eff\":\"Taglio CTAP2.1 EP\",\"7e3f3d30-3557-4442-bdae-139312178b39\":\"RSA DS100\",\"820d89ed-d65a-409e-85cb-f73f0578f82a\":\"IDmelon iOS Authenticator\",\"833b721a-ff5f-4d00-bb2e-bdda3ec01e29\":\"Feitian ePass FIDO2 Authenticator\",\"83c47309-aabb-4108-8470-8be838b573cb\":\"YubiKey Bio Series (Enterprise Profile)\",\"85203421-48f9-4355-9bc8-8a53846e5083\":\"YubiKey 5 FIPS Series with Lightning\",\"87dbc5a1-4c94-4dc8-8a47-97d800fd1f3c\":\"eWBM eFA320 FIDO2 Authenticator\",\"8836336a-f590-0921-301d-46427531eee6\":\"Thales Bio Android SDK\",\"8876631b-d4a0-427f-5773-0ec71c9e0279\":\"Solo Secp256R1 FIDO2 CTAP2 Authenticator\",\"88bbd2f0-342a-42e7-9729-dd158be5407a\":\"Precision InnaIT Key FIDO 2 Level 2 certified\",\"891494da-2c90-4d31-a9cd-4eab0aed1309\":\"S\\xE9same\",\"8976631b-d4a0-427f-5773-0ec71c9e0279\":\"Solo Tap Secp256R1 FIDO2 CTAP2 Authenticator\",\"89b19028-256b-4025-8872-255358d950e4\":\"Sentry Enterprises CTAP2 Authenticator\",\"8c97a730-3f7b-41a6-87d6-1e9b62bda6f0\":\"FT-JCOS FIDO Fingerprint Card\",\"8d1b1fcb-3c76-49a9-9129-5515b346aa02\":\"IDEMIA ID-ONE Card\",\"91ad6b93-264b-4987-8737-3a690cad6917\":\"Token Ring FIDO2 Authenticator\",\"931327dd-c89b-406c-a81e-ed7058ef36c6\":\"Swissbit iShield Key FIDO2\",\"95442b2e-f15e-4def-b270-efb106facb4e\":\"eWBM eFA310 FIDO2 Authenticator\",\"95e4d58c-056e-4a65-866d-f5a69659e880\":\"TruU Windows Authenticator\",\"970c8d9c-19d2-46af-aa32-3f448db49e35\":\"WinMagic FIDO Eazy - TPM\",\"973446ca-e21c-9a9b-99f5-9b985a67af0f\":\"ACS FIDO Authenticator Card\",\"9876631b-d4a0-427f-5773-0ec71c9e0279\":\"Somu Secp256R1 FIDO2 CTAP2 Authenticator\",\"998f358b-2dd2-4cbe-a43a-e8107438dfb3\":\"OnlyKey Secp256R1 FIDO2 CTAP2 Authenticator\",\"99bf4610-ec26-4252-b31f-7380ccd59db5\":\"ZTPass Card\",\"9c835346-796b-4c27-8898-d6032f515cc5\":\"Cryptnox FIDO2\",\"9d3df6ba-282f-11ed-a261-0242ac120002\":\"Arculus FIDO2/U2F Key Card\",\"9ddd1817-af5a-4672-a2b9-3e3dd95000a9\":\"Windows Hello\",\"9f0d8150-baa5-4c00-9299-ad62c8bb4e87\":\"GoTrust Idem Card FIDO2 Authenticator\",\"9f77e279-a6e2-4d58-b700-31e5943c6a98\":\"Hyper FIDO Pro\",\"a02167b9-ae71-4ac7-9a07-06432ebb6f1c\":\"YubiKey 5 Series with Lightning\",\"a1f52be5-dfab-4364-b51c-2bd496b14a56\":\"OCTATCO EzFinger2 FIDO2 AUTHENTICATOR\",\"a25342c0-3cdc-4414-8e46-f4807fca511c\":\"YubiKey 5 Series with NFC\",\"a3975549-b191-fd67-b8fb-017e2917fdb3\":\"Excelsecu eSecu FIDO2 NFC Security Key\",\"a4e9fc6d-4cbe-4758-b8ba-37598bb5bbaa\":\"Security Key NFC by Yubico\",\"ab32f0c6-2239-afbb-c470-d2ef4e254db6\":\"TEST (DUMMY RECORD)\",\"ab32f0c6-2239-afbb-c470-d2ef4e254db7\":\"TOKEN2 FIDO2 Security Key\",\"adce0002-35bc-c60a-648b-0b25f1f05503\":\"Chrome on Mac\",\"aeb6569c-f8fb-4950-ac60-24ca2bbe2e52\":\"HID Crescendo C2300\",\"b267239b-954f-4041-a01b-ee4f33c145b6\":\"authenton1 - CTAP2.1\",\"b50d5e0a-7f81-4959-9b12-f45407407503\":\"IDPrime 3940 FIDO\",\"b5397666-4885-aa6b-cebf-e52262a439a2\":\"Chromium Browser\",\"b6ede29c-3772-412c-8a78-539c1f4c62d2\":\"Feitian BioPass FIDO2 Plus Authenticator\",\"b84e4048-15dc-4dd0-8640-f4f60813c8af\":\"NordPass\",\"b92c3f9a-c014-4056-887f-140a2501163b\":\"Security Key by Yubico\",\"b93fd961-f2e6-462f-b122-82002247de78\":\"Android Authenticator with SafetyNet Attestation\",\"ba76a271-6eb6-4171-874d-b6428dbe3437\":\"ATKey.ProS\",\"ba86dc56-635f-4141-aef6-00227b1b9af6\":\"TruU Windows Authenticator\",\"bada5566-a7aa-401f-bd96-45619a55120d\":\"1Password\",\"bbf4b6a7-679d-f6fc-c4f2-8ac0ddf9015a\":\"Excelsecu eSecu FIDO2 PRO Security Key\",\"bc2fe499-0d8e-4ffe-96f3-94a82840cf8c\":\"OCTATCO EzQuant FIDO2 AUTHENTICATOR\",\"be727034-574a-f799-5c76-0929e0430973\":\"Crayonic KeyVault K1 (USB-NFC-BLE FIDO2 Authenticator)\",\"c1f9a0bc-1dd2-404a-b27f-8e29047a43fd\":\"YubiKey 5 FIPS Series with NFC\",\"c5703116-972b-4851-a3e7-ae1259843399\":\"NEOWAVE Badgeo FIDO2\",\"c5ef55ff-ad9a-4b9f-b580-adebafe026d0\":\"YubiKey 5 Series with Lightning\",\"c80dbd9a-533f-4a17-b941-1a2f1c7cedff\":\"HID Crescendo C3000\",\"ca4cff1b-5a81-4404-8194-59aabcf1660b\":\"IDPrime 3930 FIDO\",\"ca87cb70-4c1b-4579-a8e8-4efdd7c007e0\":\"FIDO Alliance TruU Sample FIDO2 Authenticator\",\"cb69481e-8ff7-4039-93ec-0a2729a154a8\":\"YubiKey 5 Series\",\"cc45f64e-52a2-451b-831a-4edd8022a202\":\"ToothPic Passkey Provider\",\"cd69adb5-3c7a-deb9-3177-6800ea6cb72a\":\"Thales PIN Android SDK\",\"cdbdaea2-c415-5073-50f7-c04e968640b6\":\"Excelsecu eSecu FIDO2 Security Key\",\"cfcb13a2-244f-4b36-9077-82b79d6a7de7\":\"USB/NFC Passcode Authenticator\",\"d384db22-4d50-ebde-2eac-5765cf1e2a44\":\"Excelsecu eSecu FIDO2 Fingerprint Security Key\",\"d41f5a69-b817-4144-a13c-9ebd6d9254d6\":\"ATKey.Card CTAP2.0\",\"d548826e-79b4-db40-a3d8-11116f7e8349\":\"Bitwarden\",\"d61d3b87-3e7c-4aea-9c50-441c371903ad\":\"KeyVault Secp256R1 FIDO2 CTAP2 Authenticator\",\"d7a423ad-3e19-4492-9200-78137dccc136\":\"VivoKey Apex FIDO2\",\"d821a7d4-e97c-4cb6-bd82-4237731fd4be\":\"Hyper FIDO Bio Security Key\",\"d8522d9f-575b-4866-88a9-ba99fa02f35b\":\"YubiKey Bio Series\",\"d91c5288-0ef0-49b7-b8ae-21ca0aa6b3f3\":\"KEY-ID FIDO2 Authenticator\",\"d94a29d9-52dd-4247-9c2d-8b818b610389\":\"VeriMark Guard Fingerprint Key\",\"da1fa263-8b25-42b6-a820-c0036f21ba7f\":\"ATKey.Card NFC\",\"dd4ec289-e01d-41c9-bb89-70fa845d4bf2\":\"iCloud Keychain (Managed)\",\"e1a96183-5016-4f24-b55b-e3ae23614cc6\":\"ATKey.Pro CTAP2.0\",\"e416201b-afeb-41ca-a03d-2281c28322aa\":\"ATKey.Pro CTAP2.1\",\"e77e3c64-05e3-428b-8824-0cbeb04b829d\":\"Security Key NFC by Yubico\",\"e86addcd-7711-47e5-b42a-c18257b0bf61\":\"IDCore 3121 Fido\",\"ea9b8d66-4d01-1d21-3ce4-b6b48cb575d4\":\"Google Password Manager\",\"eabb46cc-e241-80bf-ae9e-96fa6d2975cf\":\"TOKEN2 PIN Plus Security Key Series \",\"eb3b131e-59dc-536a-d176-cb7306da10f5\":\"ellipticSecure MIRkey USB Authenticator\",\"ec31b4cc-2acc-4b8e-9c01-bade00ccbe26\":\"KeyXentic FIDO2 Secp256R1 FIDO2 CTAP2 Authenticator\",\"ee041bce-25e5-4cdb-8f86-897fd6418464\":\"Feitian ePass FIDO2-NFC Authenticator\",\"ee882879-721c-4913-9775-3dfcce97072a\":\"YubiKey 5 Series\",\"efb96b10-a9ee-4b6c-a4a9-d32125ccd4a4\":\"Safenet eToken FIDO\",\"f3809540-7f14-49c1-a8b3-8f813b225541\":\"Enpass\",\"f4c63eff-d26c-4248-801c-3736c7eaa93a\":\"FIDO KeyPass S3\",\"f56f58b3-d711-4afc-ba7d-6ac05f88cb19\":\"WinMagic FIDO Eazy - Phone\",\"f7c558a0-f465-11e8-b568-0800200c9a66\":\"KONAI Secp256R1 FIDO2 Conformance Testing CTAP2 Authenticator\",\"f8a011f3-8c0a-4d15-8006-17111f9edc7d\":\"Security Key by Yubico\",\"fa2b99dc-9e39-4257-8f92-4a30d23c4118\":\"YubiKey 5 Series with NFC\",\"fbefdf68-fe86-0106-213e-4d5fa24cbe2e\":\"Excelsecu eSecu FIDO2 NFC Security Key\",\"fbfc3007-154e-4ecc-8c0b-6e020557d7bd\":\"iCloud Keychain\",\"fcb1bcb4-f370-078c-6993-bc24d0ae3fbe\":\"Ledger Nano X FIDO2 Authenticator\",\"fdb141b2-5d84-443e-8a35-4698c205a502\":\"KeePassXC\",\"fec067a1-f1d0-4c5e-b4c0-cc3237475461\":\"KX701 SmartToken FIDO\"};var W=new TextDecoder(\"utf-8\");function S(e){return typeof e==\"string\"&&(e=o(e)),JSON.parse(W.decode(e))}function b(e){typeof e==\"string\"&&(e=o(e));let t=new DataView(e.slice(32,33)).getUint8(0);return{rpIdHash:$(e),flags:{userPresent:!!(t&1),userVerified:!!(t&4),backupEligibility:!!(t&8),backupState:!!(t&16),attestedData:!!(t&64),extensionsIncluded:!!(t&128)},signCount:new DataView(e.slice(33,37)).getUint32(0,!1),aaguid:G(e)}}function $(e){return n(e.slice(0,32))}function G(e){if(e.byteLength<53)return\"00000000-0000-0000-0000-000000000000\";let t=e.slice(37,53),a=C(t);return`${a.substring(0,8)}-${a.substring(8,12)}-${a.substring(12,16)}-${a.substring(16,20)}-${a.substring(20,32)}`}function E(e){switch(e){case-7:return\"ES256\";case-8:return\"EdDSA\";case-257:return\"RS256\";default:throw new Error(`Unknown algorithm code: ${e}`)}}function z(e){let t=b(e.response.authenticatorData);return N(e,t)}function N(e,t){let a=t.aaguid;return{authenticator:{aaguid:a,counter:t.signCount,icon_light:\"https://webauthn.passwordless.id/authenticators/\"+a+\"-light.png\",icon_dark:\"https://webauthn.passwordless.id/authenticators/\"+a+\"-dark.png\",name:p[a]??\"Unknown\"},credential:{id:e.id,publicKey:e.response.publicKey,algorithm:E(e.response.publicKeyAlgorithm),transports:e.response.transports},synced:t.flags.backupEligibility,user:e.user,userVerified:t.flags.userVerified}}function I(e,t){return{credentialId:e.id,userId:e.response.userHandle,counter:t.signCount,userVerified:t.flags.userVerified,authenticatorAttachment:e.authenticatorAttachment}}function j(e){let t=b(e.response.authenticatorData);return I(e,t)}function J(){let e=crypto.getRandomValues(new Uint8Array(18));return n(e)}async function X(e,t){if(typeof e==\"function\"){let a=e(t);return a instanceof Promise?await a:a}return e===t}async function m(e,t){return!await X(e,t)}async function _(e,t){let a=S(e.response.clientDataJSON),r=b(e.response.authenticatorData);if(!r.aaguid)throw new Error(\"Unexpected errror, no AAGUID.\");if(a.type!==\"webauthn.create\")throw new Error(`Unexpected ClientData type: ${a.type}`);if(await m(t.origin,a.origin))throw new Error(`Unexpected ClientData origin: ${a.origin}`);if(await m(t.challenge,a.challenge))throw new Error(`Unexpected ClientData challenge: ${a.challenge}`);return l.toRegistrationInfo(e,r)}async function q(e,t,a){if(e.id!==t.id)throw new Error(`Credential ID mismatch: ${e.id} vs ${t.id}`);if(!await U({algorithm:t.algorithm,publicKey:t.publicKey,authenticatorData:e.response.authenticatorData,clientData:e.response.clientDataJSON,signature:e.response.signature,verbose:a.verbose}))throw new Error(`Invalid signature: ${e.response.signature}`);let i=S(e.response.clientDataJSON),c=b(e.response.authenticatorData);if(a.verbose&&(console.debug(i),console.debug(c)),i.type!==\"webauthn.get\")throw new Error(`Unexpected clientData type: ${i.type}`);if(await m(a.origin,i.origin))throw new Error(`Unexpected ClientData origin: ${i.origin}`);if(await m(a.challenge,i.challenge))throw new Error(`Unexpected ClientData challenge: ${i.challenge}`);let d=a.domain??new URL(i.origin).hostname,h=n(await A(f(d)));if(c.rpIdHash!==h)throw new Error(`Unexpected RpIdHash: ${c.rpIdHash} vs ${h}`);if(!c.flags.userPresent)throw new Error(\"Unexpected authenticator flags: missing userPresent\");if(!c.flags.userVerified&&a.userVerified)throw new Error(\"Unexpected authenticator flags: missing userVerified\");if(a.counter&&c.signCount<=a.counter)throw new Error(`Unexpected authenticator counter: ${c.signCount} (should be > ${a.counter})`);return I(e,c)}function T(e){switch(e){case\"RS256\":return{name:\"RSASSA-PKCS1-v1_5\",hash:\"SHA-256\"};case\"ES256\":return{name:\"ECDSA\",namedCurve:\"P-256\",hash:\"SHA-256\"};default:throw new Error(`Unknown or unsupported crypto algorithm: ${e}. Only 'RS256' and 'ES256' are supported.`)}}async function R(e,t){let a=T(e),r=o(t);return crypto.subtle.importKey(\"spki\",r,a,!1,[\"verify\"])}async function U({algorithm:e,publicKey:t,authenticatorData:a,clientData:r,signature:i,verbose:c}){let d=await R(e,t);c&&console.debug(d);let h=await A(o(r)),P=O(o(a),h);c&&(console.debug(\"Algorithm: \"+e),console.debug(\"Public key: \"+t),console.debug(\"Data: \"+n(P)),console.debug(\"Signature: \"+i));let D=o(i);e==\"ES256\"&&(D=Z(D));let x=T(e);return await crypto.subtle.verify(x,d,D,P)}function Z(e){let t=new Uint8Array(e),a=t[4]===0?5:4,r=a+32,i=t[r+2]===0?r+3:r+2,c=t.slice(a,r),d=t.slice(i);return new Uint8Array([...c,...d])}var Q={client:w,server:F,parsers:l,utils:u,authenticatorMetadata:p},se=Q;export{p as authenticatorMetadata,w as client,se as default,l as parsers,F as server,u as utils};\n//# sourceMappingURL=webauthn.min.js.map\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nimport Onboarding from './onboarding'\nimport Profile from './profile'\nimport Validate from \"./validate\";\nimport PasskeyLogin from \"./passkey-login\";\nimport PasskeyTableManager from \"./passkey-table-manager\";\n\n/**\n * The Global rsssl_onboard object is defined in the PHP file that enqueues this script.\n * @global rsssl_onboard\n * It contains the following properties:\n * @typedef {Object} rsssl_onboard\n * @property {string} root - The root URL of the site.\n * @property {string} redirect_to - The URL to redirect to after the onboarding process is complete.\n * @property {string} user_id - The ID of the user.\n * @property {string} login_nonce - The nonce for the login.\n * @property {string} totp_data - The data for the TOTP.\n * @property {string} totp_data.totp_url - The URL for the TOTP.\n * @property {string} totp_data.backup_codes - The backup codes for the TOTP.\n * @property {string} totp_data.key - The key for the TOTP.\n * @property {string} totp_data.authcode - The authcode for the TOTP.\n * @property {string} totp_data.provider - The provider for the TOTP.\n * @property {string} totp_data.redirect_to - The URL to redirect to after the TOTP process is complete.\n * @property {string} display_name- The error message for the TOTP.\n */\n\n/**\n * The Global rsssl_profile object is defined in the PHP file that enqueues this script.\n * @global rsssl_profile\n * It contains the following properties:\n * @typedef {Object} rsssl_profile\n */\n\n/**\n * The Global rsssl_validate object is defined in the PHP file that enqueues this script.\n * @global rsssl_validate\n * It contains the following properties:\n * @typedef {Object} rsssl_validate\n */\n\n/**\n * The Global rsssl_validate object is defined in the PHP file that enqueues this script.\n * @global rsssl_login\n * It contains the following properties:\n * @typedef {Object} rsssl_login\n */\n\nwindow.onload = function() {\n    if(typeof rsssl_onboard !== 'undefined') {\n        let onboarding = new Onboarding(rsssl_onboard.root, rsssl_onboard);\n        onboarding.init();\n    }\n\n    if (typeof rsssl_profile !== 'undefined') {\n        let profile = new Profile(rsssl_profile.root, rsssl_profile);\n        profile.init();\n        const tableManager = new PasskeyTableManager(rsssl_profile.root, rsssl_profile);\n        tableManager.init();\n    }\n\n    if(typeof rsssl_validate !== 'undefined') {\n        let validate = new Validate(rsssl_validate.root, rsssl_validate);\n        validate.init();\n    }\n    if(typeof rsssl_login !== 'undefined') {\n        let login = new PasskeyLogin(rsssl_login.root, rsssl_login);\n        login.init();\n    }\n}"],"names":["qrcode","BaseAuth","_createClass","root","settings","_this","_classCallCheck","_defineProperty","id","document","getElementById","name","querySelector","concat","value","urlExtension","data","method","arguments","length","undefined","url","fetchParams","headers","body","JSON","stringify","fetch","callback","element","getElement","addEventListener","e","preventDefault","error","console","totp_url","totp_data","qr","addData","make","qrElem","svgString","createSvgTag","replace","innerHTML","TextToCode","backup_codes","TextToCodeString","forEach","item","downloadLink","createElement","setAttribute","encodeURIComponent","style","display","appendChild","click","removeChild","text","key","navigator","clipboard","writeText","then","originalText","innerText","translatables","keyCopied","color","setTimeout","err","keyCopiedFailed","translatableStrings","webauthn_not_available","unknown_error","response_error","passkey_not_found","passkey_login_error","passkey_registration_error","passkey_login_success","passkey_configuration","error_assertion","notice_inform","register_passkey","network_not_ok","error_complete_registration","usb","nfc","ble","internal","cross_platform","unknown","pending","success","login","login_failed","log_in_with_passkey","or","_regeneratorRuntime","t","r","Object","prototype","n","hasOwnProperty","o","defineProperty","i","Symbol","a","iterator","c","asyncIterator","u","toStringTag","define","enumerable","configurable","writable","wrap","Generator","create","Context","makeInvokeMethod","tryCatch","type","arg","call","h","l","f","s","y","GeneratorFunction","GeneratorFunctionPrototype","p","d","getPrototypeOf","v","values","g","defineIteratorMethods","_invoke","AsyncIterator","invoke","_typeof","resolve","__await","callInvokeWithMethodAndArg","Error","done","delegate","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","TypeError","resultName","next","nextLoc","pushTryEntry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","isNaN","displayName","isGeneratorFunction","constructor","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","reverse","pop","prev","charAt","slice","stop","rval","handle","complete","finish","_catch","delegateYield","asyncGeneratorStep","_asyncToGenerator","apply","_next","_throw","_defineProperties","_toPropertyKey","_toPrimitive","toPrimitive","String","Number","_callSuper","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","_assertThisInitialized","ReferenceError","Boolean","valueOf","bind","_inherits","_setPrototypeOf","Passkey","Onboarding","_BaseAuth","init","endpoints","passkey","that","endpoint","endpointsElement","event","performFetchOp","response","json","window","location","href","redirect_to","logFetchError","endpointElem","_handleClick","handleClick","selectedProvider","getCheckedInputValue","provider","user_id","login_nonce","validation_check","handleValidation","removeEventListener","fireRegistration","_ref","_callee","sendData","_data","_callee$","_context","validation_action","token","t0","log","ok","displayTwoFaOnboardingError","_x","_x2","totpSubmit","_ref2","_callee2","authCode","_callee2$","_context2","_x3","resendButton","responseData","message","clearTwoFactorPrompt","displayTwoFaOnboardingSuccess","jsonErr","downloadButton","download_codes","passkeySubmit","copyTextAndShowMessage","readyState","qr_generator","loginForm","errorDiv","className","insertAdjacentElement","remove","messageDiv","elements","getElementsByClassName","Login_Passkey","form","getElementsByName","addPasskeyButton","passkeyButton","getAttribute","handlePasskeyLogin","_this2","submitButton","passkeyButtonContainer","justifyContent","alignItems","orDivider","lockIcon","marginRight","insertBefore","firstChild","parentNode","nextSibling","errorContainer","fontSize","marginTop","textAlign","width","wordWrap","wordBreak","get","set","origAddEventListener","EventTarget","listener","options","PasskeyTableManager","_len","args","Array","_key","tableContainer","initEventListeners","fetchDataAndRender","target","matches","handleRemove","dataset","deviceId","renderPasskeyTable","rows","tableHTML","buildTableRows","tableBody","count","output","row","authDeviceId","created_at","updated_at","_this3","entry_id","_this4","removeUrl","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","_arrayLikeToArray","toString","from","test","isArray","client","base64url","Decoder","cbor","BUTTON_CLASSES","failed","knownAuthenticators","onboarding","manager","translate","passkey_configure_manual_login","BUTTON_TEXT","stepThree","observer","MutationObserver","handleMutation","observe","attributes","assignClickListener","handlePasskeyRegister","mutations","mutation","attributeName","displayStyle","getComputedStyle","showPasskeyOptions","updateRegisterButtonState","state","_workButton$classList","workButton","logButtonState","disabled","classList","add","_handlePasskeyLogin","userHandle","userNameElement","user_login","requestData","errorData","_errorData","publicKeyCredentialRequestOptions","assertion","isAvailable","handleError","localStorage","getItem","credentials","status","t1","prepareCredentialRequest","publicKey","sendAssertion","t2","_prepareCredentialRequest","challenge","toBuffer","allowCredentials","map","cred","_objectSpread","_sendAssertion","_callee3","_result","result","_callee3$","_context3","credential","rawId","encode","authenticatorData","clientDataJSON","signature","includes","onbeforeunload","mainElement","container","_handlePasskeyRegister","_callee4","publicKeyCreationOptions","registrationResult","_form","_callee4$","_context4","fetchPublicKeyOptions","completeRegistration","reload","_fetchPublicKeyOptions","_callee5","_callee5$","_context5","generateUniqueUserHandle","user","display_name","pubKeyCredParams","alg","rp","hostname","authenticatorSelection","authenticatorAttachment","userVerification","_completeRegistration","_callee6","deviceName","_callee6$","_context6","getDeviceName","attestationObject","authDevice","device_name","setItem","reason","_x4","_fireRegistration","_callee7","automatic","_args7","_callee7$","_context7","decodedAttestationObject","decodeAllSync","Uint8Array","authData","aaguid","aaguidString","_byte","padStart","join","getTransports","transports","Date","now","Profile","qrCodeContainer","enableCheckbox","tableRowSelection","methodSelection","querySelectorAll","validationEmail","change2faConfig","passKeyContainer","passkeySection","origBeforeUnload","profileForm","dispatchEvent","Event","thereIsAnAddDevice","checked","parent","selectedMethod","_selectedMethod","_parent","action","rsssl_profile","profile","ajax_url","URLSearchParams","inPutField","opacity","ajaxUrl","inputField","requestSubmit","fetchPasskeyData","nonce","registered","last_used","actions","Validate","validateButton","PasskeyLogin","onload","rsssl_onboard","tableManager","rsssl_validate","validate","rsssl_login"],"sourceRoot":""}