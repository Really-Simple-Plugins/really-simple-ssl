{"version":3,"file":"checkTypes.js","names":["_iterateJsdoc","_interopRequireDefault","require","_jsdoccomment","obj","__esModule","default","strictNativeTypes","adjustNames","type","preferred","isGenericMatch","typeNodeName","node","parentNode","ret","parentMeta","meta","brackets","dot","dotBracketEnd","match","slice","length","bracketEnd","endsWith","value","replace","getMessage","upperCase","_default","iterateJsdoc","jsdocNode","sourceCode","report","utils","settings","context","jsdocTagsWithPossibleType","filterTags","tag","Boolean","tagMightHaveTypePosition","preferredTypes","preferredTypesOriginal","structuredTags","mode","injectObjectPreferredTypes","info","message","replacement","infoUC","typeToInject","Object","noDefaults","unifyParentAndChildTypeChecks","exemptTagContexts","options","getPreferredTypeInfo","_type","property","hasMatchingPreferredType","typeName","isNameOfGeneric","undefined","_parentNode$meta","_parentNode$meta2","checkPostFixes","some","checkPostFix","directNameMatch","values","includes","unifiedSyntaxParentMatch","checkNativeTypes","invalidTypes","changedPreferred","strictNativeType","_parentNode$elements","_parentNode$left","_parentNode$left2","elements","left","toLowerCase","push","getInvalidTypes","tagName","nameInTag","idx","types","preferredSetting","nextItem","skipRootChecking","name","startsWith","reportSettings","entries","typs","Array","isArray","jsdocTag","typeAst","tryParse","parse","traverse","fixedType","stringify","fix","fixer","replaceText","getText","badType","preferredType","msg","tagValue","JSON","iterateAllJsdocs","docs","description","url","fixable","schema","additionalProperties","properties","items","oneOf","exports","module"],"sources":["../../src/rules/checkTypes.js"],"sourcesContent":["import iterateJsdoc from '../iterateJsdoc.js';\nimport {\n  parse,\n  stringify,\n  traverse,\n  tryParse,\n} from '@es-joy/jsdoccomment';\n\nconst strictNativeTypes = [\n  'undefined',\n  'null',\n  'boolean',\n  'number',\n  'bigint',\n  'string',\n  'symbol',\n  'object',\n  'Array',\n  'Function',\n  'Date',\n  'RegExp',\n];\n\n/**\n * Adjusts the parent type node `meta` for generic matches (or type node\n * `type` for `JsdocTypeAny`) and sets the type node `value`.\n * @param {string} type The actual type\n * @param {string} preferred The preferred type\n * @param {boolean} isGenericMatch\n * @param {string} typeNodeName\n * @param {import('jsdoc-type-pratt-parser').NonRootResult} node\n * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n * @returns {void}\n */\nconst adjustNames = (type, preferred, isGenericMatch, typeNodeName, node, parentNode) => {\n  let ret = preferred;\n  if (isGenericMatch) {\n    const parentMeta = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n      parentNode\n    ).meta;\n    if (preferred === '[]') {\n      parentMeta.brackets = 'square';\n      parentMeta.dot = false;\n      ret = 'Array';\n    } else {\n      const dotBracketEnd = preferred.match(/\\.(?:<>)?$/u);\n      if (dotBracketEnd) {\n        parentMeta.brackets = 'angle';\n        parentMeta.dot = true;\n        ret = preferred.slice(0, -dotBracketEnd[0].length);\n      } else {\n        const bracketEnd = preferred.endsWith('<>');\n        if (bracketEnd) {\n          parentMeta.brackets = 'angle';\n          parentMeta.dot = false;\n          ret = preferred.slice(0, -2);\n        } else if (\n          parentMeta?.brackets === 'square' &&\n          (typeNodeName === '[]' || typeNodeName === 'Array')\n        ) {\n          parentMeta.brackets = 'angle';\n          parentMeta.dot = false;\n        }\n      }\n    }\n  } else if (type === 'JsdocTypeAny') {\n    node.type = 'JsdocTypeName';\n  }\n\n  /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n    node\n  ).value = ret.replace(/(?:\\.|<>|\\.<>|\\[\\])$/u, '');\n\n  // For bare pseudo-types like `<>`\n  if (!ret) {\n    /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n      node\n    ).value = typeNodeName;\n  }\n};\n\n/**\n * @param {boolean} [upperCase]\n * @returns {string}\n */\nconst getMessage = (upperCase) => {\n  return 'Use object shorthand or index signatures instead of ' +\n  '`' + (upperCase ? 'O' : 'o') + 'bject`, e.g., `{[key: string]: string}`';\n};\n\nexport default iterateJsdoc(({\n  jsdocNode,\n  sourceCode,\n  report,\n  utils,\n  settings,\n  context,\n}) => {\n  const jsdocTagsWithPossibleType = utils.filterTags((tag) => {\n    return Boolean(utils.tagMightHaveTypePosition(tag.tag));\n  });\n\n  const\n    /**\n     * @type {{\n     *   preferredTypes: import('../iterateJsdoc.js').PreferredTypes,\n     *   structuredTags: import('../iterateJsdoc.js').StructuredTags,\n     *   mode: import('../jsdocUtils.js').ParserMode\n     * }}\n     */\n    {\n      preferredTypes: preferredTypesOriginal,\n      structuredTags,\n      mode,\n    } = settings;\n  /* eslint-enable jsdoc/valid-types -- Old version */\n\n  const injectObjectPreferredTypes = !('Object' in preferredTypesOriginal ||\n    'object' in preferredTypesOriginal ||\n    'object.<>' in preferredTypesOriginal ||\n    'Object.<>' in preferredTypesOriginal ||\n    'object<>' in preferredTypesOriginal);\n\n  /**\n   * @type {{\n   *   message: string,\n   *   replacement: false\n   * }}\n   */\n  const info = {\n    message: getMessage(),\n    replacement: false,\n  };\n\n  /**\n   * @type {{\n   *   message: string,\n   *   replacement: false\n   * }}\n   */\n  const infoUC = {\n    message: getMessage(true),\n    replacement: false,\n  };\n\n  /** @type {import('../iterateJsdoc.js').PreferredTypes} */\n  const typeToInject = mode === 'typescript' ?\n    {\n      Object: 'object',\n      'object.<>': info,\n      'Object.<>': infoUC,\n      'object<>': info,\n      'Object<>': infoUC,\n    } :\n    {\n      Object: 'object',\n      'object.<>': 'Object<>',\n      'Object.<>': 'Object<>',\n      'object<>': 'Object<>',\n    };\n\n  /** @type {import('../iterateJsdoc.js').PreferredTypes} */\n  const preferredTypes = {\n    ...injectObjectPreferredTypes ?\n      typeToInject :\n      {},\n    ...preferredTypesOriginal,\n  };\n\n  const\n    /**\n     * @type {{\n     *   noDefaults: boolean,\n     *   unifyParentAndChildTypeChecks: boolean,\n     *   exemptTagContexts: ({\n     *     tag: string,\n     *     types: true|string[]\n     *   })[]\n     * }}\n     */ {\n      noDefaults,\n      unifyParentAndChildTypeChecks,\n      exemptTagContexts = [],\n    } = context.options[0] || {};\n\n  /**\n   * Gets information about the preferred type: whether there is a matching\n   * preferred type, what the type is, and whether it is a match to a generic.\n   * @param {string} _type Not currently in use\n   * @param {string} typeNodeName\n   * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n   * @param {string|undefined} property\n   * @returns {[hasMatchingPreferredType: boolean, typeName: string, isGenericMatch: boolean]}\n   */\n  const getPreferredTypeInfo = (_type, typeNodeName, parentNode, property) => {\n    let hasMatchingPreferredType = false;\n    let isGenericMatch = false;\n    let typeName = typeNodeName;\n\n    const isNameOfGeneric = parentNode !== undefined && parentNode.type === 'JsdocTypeGeneric' && property === 'left';\n    if (unifyParentAndChildTypeChecks || isNameOfGeneric) {\n      const brackets = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n        parentNode\n      )?.meta?.brackets;\n      const dot = /** @type {import('jsdoc-type-pratt-parser').GenericResult} */ (\n        parentNode\n      )?.meta?.dot;\n\n      if (brackets === 'angle') {\n        const checkPostFixes = dot ? [\n          '.', '.<>',\n        ] : [\n          '<>',\n        ];\n        isGenericMatch = checkPostFixes.some((checkPostFix) => {\n          if (preferredTypes?.[typeNodeName + checkPostFix] !== undefined) {\n            typeName += checkPostFix;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      if (\n        !isGenericMatch && property &&\n        /** @type {import('jsdoc-type-pratt-parser').NonRootResult} */ (\n          parentNode\n        ).type === 'JsdocTypeGeneric'\n      ) {\n        const checkPostFixes = dot ? [\n          '.', '.<>',\n        ] : [\n          brackets === 'angle' ? '<>' : '[]',\n        ];\n\n        isGenericMatch = checkPostFixes.some((checkPostFix) => {\n          if (preferredTypes?.[checkPostFix] !== undefined) {\n            typeName = checkPostFix;\n\n            return true;\n          }\n\n          return false;\n        });\n      }\n    }\n\n    const directNameMatch = preferredTypes?.[typeNodeName] !== undefined &&\n      !Object.values(preferredTypes).includes(typeNodeName);\n    const unifiedSyntaxParentMatch = property && directNameMatch && unifyParentAndChildTypeChecks;\n    isGenericMatch = isGenericMatch || Boolean(unifiedSyntaxParentMatch);\n\n    hasMatchingPreferredType = isGenericMatch ||\n      directNameMatch && !property;\n\n    return [\n      hasMatchingPreferredType, typeName, isGenericMatch,\n    ];\n  };\n\n  /**\n   * Iterates strict types to see if any should be added to `invalidTypes` (and\n   * the the relevant strict type returned as the new preferred type).\n   * @param {string} typeNodeName\n   * @param {string|undefined} preferred\n   * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n   * @param {(string|false|undefined)[][]} invalidTypes\n   * @returns {string|undefined} The `preferred` type string, optionally changed\n   */\n  const checkNativeTypes = (typeNodeName, preferred, parentNode, invalidTypes) => {\n    let changedPreferred = preferred;\n    for (const strictNativeType of strictNativeTypes) {\n      if (\n        strictNativeType === 'object' &&\n        (\n          // This is not set to remap with exact type match (e.g.,\n          //   `object: 'Object'`), so can ignore (including if circular)\n          !preferredTypes?.[typeNodeName] ||\n          // Although present on `preferredTypes` for remapping, this is a\n          //   parent object without a parent match (and not\n          //   `unifyParentAndChildTypeChecks`) and we don't want\n          //   `object<>` given TypeScript issue https://github.com/microsoft/TypeScript/issues/20555\n          /**\n           * @type {import('jsdoc-type-pratt-parser').GenericResult}\n           */\n          (\n            parentNode\n          )?.elements?.length && (\n          /**\n           * @type {import('jsdoc-type-pratt-parser').GenericResult}\n           */\n            (\n              parentNode\n            )?.left?.type === 'JsdocTypeName' &&\n            /**\n             * @type {import('jsdoc-type-pratt-parser').GenericResult}\n             */\n            (parentNode)?.left?.value === 'Object'\n          )\n        )\n      ) {\n        continue;\n      }\n\n      if (strictNativeType !== typeNodeName &&\n        strictNativeType.toLowerCase() === typeNodeName.toLowerCase() &&\n\n        // Don't report if user has own map for a strict native type\n        (!preferredTypes || preferredTypes?.[strictNativeType] === undefined)\n      ) {\n        changedPreferred = strictNativeType;\n        invalidTypes.push([\n          typeNodeName, changedPreferred,\n        ]);\n        break;\n      }\n    }\n\n    return changedPreferred;\n  };\n\n  /**\n   * Collect invalid type info.\n   * @param {string} type\n   * @param {string} value\n   * @param {string} tagName\n   * @param {string} nameInTag\n   * @param {number} idx\n   * @param {string|undefined} property\n   * @param {import('jsdoc-type-pratt-parser').NonRootResult} node\n   * @param {import('jsdoc-type-pratt-parser').NonRootResult|undefined} parentNode\n   * @param {(string|false|undefined)[][]} invalidTypes\n   * @returns {void}\n   */\n  const getInvalidTypes = (type, value, tagName, nameInTag, idx, property, node, parentNode, invalidTypes) => {\n    let typeNodeName = type === 'JsdocTypeAny' ? '*' : value;\n\n    const [\n      hasMatchingPreferredType,\n      typeName,\n      isGenericMatch,\n    ] = getPreferredTypeInfo(type, typeNodeName, parentNode, property);\n\n    let preferred;\n    let types;\n    if (hasMatchingPreferredType) {\n      const preferredSetting = preferredTypes[typeName];\n      typeNodeName = typeName === '[]' ? typeName : typeNodeName;\n\n      if (!preferredSetting) {\n        invalidTypes.push([\n          typeNodeName,\n        ]);\n      } else if (typeof preferredSetting === 'string') {\n        preferred = preferredSetting;\n        invalidTypes.push([\n          typeNodeName, preferred,\n        ]);\n      } else if (preferredSetting && typeof preferredSetting === 'object') {\n        const nextItem = preferredSetting.skipRootChecking && jsdocTagsWithPossibleType[idx + 1];\n\n        if (!nextItem || !nextItem.name.startsWith(`${nameInTag}.`)) {\n          preferred = preferredSetting.replacement;\n          invalidTypes.push([\n            typeNodeName,\n            preferred,\n            preferredSetting.message,\n          ]);\n        }\n      } else {\n        utils.reportSettings(\n          'Invalid `settings.jsdoc.preferredTypes`. Values must be falsy, a string, or an object.',\n        );\n\n        return;\n      }\n    } else if (Object.entries(structuredTags).some(([\n      tag,\n      {\n        type: typs,\n      },\n    ]) => {\n      types = typs;\n\n      return tag === tagName &&\n        Array.isArray(types) &&\n        !types.includes(typeNodeName);\n    })) {\n      invalidTypes.push([\n        typeNodeName, types,\n      ]);\n    } else if (!noDefaults && type === 'JsdocTypeName') {\n      preferred = checkNativeTypes(typeNodeName, preferred, parentNode, invalidTypes);\n    }\n\n    // For fixer\n    if (preferred) {\n      adjustNames(type, preferred, isGenericMatch, typeNodeName, node, parentNode);\n    }\n  };\n\n  for (const [\n    idx,\n    jsdocTag,\n  ] of jsdocTagsWithPossibleType.entries()) {\n    /** @type {(string|false|undefined)[][]} */\n    const invalidTypes = [];\n    let typeAst;\n\n    try {\n      typeAst = mode === 'permissive' ? tryParse(jsdocTag.type) : parse(jsdocTag.type, mode);\n    } catch {\n      continue;\n    }\n\n    const {\n      tag: tagName,\n      name: nameInTag,\n    } = jsdocTag;\n\n    traverse(typeAst, (node, parentNode, property) => {\n      const {\n        type,\n        value,\n      } =\n        /**\n         * @type {import('jsdoc-type-pratt-parser').NameResult}\n         */ (node);\n      if (![\n        'JsdocTypeName', 'JsdocTypeAny',\n      ].includes(type)) {\n        return;\n      }\n\n      getInvalidTypes(type, value, tagName, nameInTag, idx, property, node, parentNode, invalidTypes);\n    });\n\n    if (invalidTypes.length) {\n      const fixedType = stringify(typeAst);\n\n      /**\n       * @type {import('eslint').Rule.ReportFixer}\n       */\n      const fix = (fixer) => {\n        return fixer.replaceText(\n          jsdocNode,\n          sourceCode.getText(jsdocNode).replace(\n            `{${jsdocTag.type}}`,\n            `{${fixedType}}`,\n          ),\n        );\n      };\n\n      for (const [\n        badType,\n        preferredType = '',\n        msg,\n      ] of invalidTypes) {\n        const tagValue = jsdocTag.name ? ` \"${jsdocTag.name}\"` : '';\n        if (exemptTagContexts.some(({\n          tag,\n          types,\n        }) => {\n          return tag === tagName &&\n            (types === true || types.includes(jsdocTag.type));\n        })) {\n          continue;\n        }\n\n        report(\n          msg ||\n            `Invalid JSDoc @${tagName}${tagValue} type \"${badType}\"` +\n            (preferredType ? '; ' : '.') +\n            (preferredType ? `prefer: ${JSON.stringify(preferredType)}.` : ''),\n          preferredType ? fix : null,\n          jsdocTag,\n          msg ? {\n            tagName,\n            tagValue,\n          } : undefined,\n        );\n      }\n    }\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid types.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/check-types.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          exemptTagContexts: {\n            items: {\n              additionalProperties: false,\n              properties: {\n                tag: {\n                  type: 'string',\n                },\n                types: {\n                  oneOf: [\n                    {\n                      type: 'boolean',\n                    },\n                    {\n                      items: {\n                        type: 'string',\n                      },\n                      type: 'array',\n                    },\n                  ],\n                },\n              },\n              type: 'object',\n            },\n            type: 'array',\n          },\n          noDefaults: {\n            type: 'boolean',\n          },\n          unifyParentAndChildTypeChecks: {\n            type: 'boolean',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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"}